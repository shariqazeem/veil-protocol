# ZK Integration

This is the core differentiator of Veil Protocol — a complete end-to-end ZK proof pipeline with **real on-chain verification** via the Garaga UltraKeccakZKHonk verifier.

## Overview

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  Noir Circuit │ ──▶ │ BB Prover    │ ──▶ │ Garaga CLI   │ ──▶ │ On-Chain     │
│  (Poseidon)  │     │ (UltraHonk)  │     │ (Calldata)   │     │ Verifier     │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
     ACIR              7KB proof          2835 felt252s        Result<Span<u256>>
```

## The Noir Circuit

**Location**: `circuits/ghostsats/src/main.nr`

The circuit proves two things:
1. The prover **knows** a `secret` and `blinder` that produce a given `zk_commitment`
2. A `nullifier_hash` is correctly derived from the `secret`

```noir
fn main(
    secret: Field,
    blinder: Field,
    zk_commitment: pub Field,
    nullifier_hash: pub Field,
    denomination: pub Field,
) {
    // Verify commitment
    let computed = std::hash::poseidon::bn254::hash_3([secret, blinder, denomination]);
    assert(computed == zk_commitment);

    // Verify nullifier
    let computed_nullifier = std::hash::poseidon::bn254::hash_2([secret, 1]);
    assert(computed_nullifier == nullifier_hash);
}
```

### Private Inputs (never on-chain)
- `secret` — Random 254-bit value, generated during deposit
- `blinder` — Random 254-bit value, prevents brute-force

### Public Inputs (embedded in proof, verified on-chain)
- `zk_commitment` — Poseidon_BN254(secret, blinder, denomination)
- `nullifier_hash` — Poseidon_BN254(secret, 1)
- `denomination` — The USDC tier (0, 1, or 2)

## Proof Generation Pipeline

### Step 1: Witness Generation

```bash
nargo execute --program-dir circuits/ghostsats/
```

Reads `Prover.toml` with private + public inputs, executes the ACIR circuit, outputs a witness file.

### Step 2: Proof Generation

```bash
bb prove -s ultra_honk --oracle_hash keccak \
  -b circuits/ghostsats/target/ghostsats.json \
  -w circuits/ghostsats/target/witness.gz \
  -o proof
```

Barretenberg generates an **UltraKeccakZKHonk** proof (~7KB binary). This proving system is chosen because Garaga has an efficient on-chain verifier for it.

### Step 3: Verification Key

```bash
bb write_vk -s ultra_honk --oracle_hash keccak \
  -b circuits/ghostsats/target/ghostsats.json \
  -o vk
```

The verification key is baked into the Garaga verifier contract at deploy time.

### Step 4: Calldata Generation

```bash
garaga calldata --system ultra_keccak_zk_honk \
  --proof proof --vk vk \
  --public-inputs target/public_inputs \
  --format array
```

Garaga converts the binary proof into **2835 felt252 values** — the proof itself plus MSM and KZG hints that make on-chain verification gas-efficient.

## On-Chain Verification

### Garaga Verifier Contract

The `UltraKeccakZKHonkVerifier` contract (generated by Garaga) exposes:

```cairo
fn verify_ultra_keccak_zk_honk_proof(
    self: @TContractState,
    full_proof_with_hints: Span<felt252>,
) -> Result<Span<u256>, felt252>;
```

- **Input**: 2835 felt252 values (proof + MSM/KZG hints)
- **Output**: `Ok(public_inputs)` or `Err(error_code)`
- **Public inputs**: `Span<u256>` containing `[commitment, nullifier, denomination]`

### ShieldedPool Verification

```cairo
// In withdraw_private:
let verifier = IZKVerifierDispatcher { contract_address: verifier_addr };
let result = verifier.verify_ultra_keccak_zk_honk_proof(proof.span());
assert(result.is_ok(), 'ZK proof verification failed');
```

The contract:
1. Calls the Garaga verifier with the proof
2. Checks the proof is valid
3. Verifies the nullifier hasn't been used (double-spend protection)
4. Verifies the commitment exists in the Merkle tree
5. Transfers WBTC to the recipient

## BN254 ↔ Stark Field Handling

Poseidon BN254 outputs values in the BN254 field (~2^254). Starknet uses felt252 (~2^251.5). To handle this:

```typescript
const STARK_PRIME = 0x800000000000011000000000000000000000000000000000000000000000001n;

function computeZKCommitment(secret, blinder, denomination) {
    const commitment = poseidon3([secret, blinder, denomination]);
    // Reduce to felt252 range
    return commitment % STARK_PRIME;
}
```

There's a ~16% chance a raw BN254 output exceeds the Stark prime. During deposit, if this happens, a new blinder is generated and the commitment is recomputed (up to 10 retries).

## Prover.toml Format

```toml
secret = "0x1234..."
blinder = "0x5678..."
zk_commitment = "0xabcd..."
nullifier_hash = "0xef01..."
denomination = "0x01"
```

All values are hex-encoded BN254 field elements.

## Security Properties

| Property | Guarantee |
|----------|-----------|
| **Soundness** | Cannot generate a valid proof without knowing secret + blinder |
| **Zero-knowledge** | Proof reveals nothing about secret or blinder |
| **Non-malleability** | Proof cannot be modified to verify with different public inputs |
| **Nullifier binding** | Each secret produces exactly one nullifier — no aliasing |
| **On-chain verification** | Garaga verifier is a deployed contract, not a mock |
