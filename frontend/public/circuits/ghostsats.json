{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"11966805079119562398","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"blinder","type":{"kind":"field"},"visibility":"private"},{"name":"zk_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"denomination","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"10038774976705379050":{"error_kind":"string","string":"Recipient cannot be zero"},"13092923600342307159":{"error_kind":"string","string":"Invalid commitment preimage"},"14561130511985968207":{"error_kind":"string","string":"Invalid nullifier derivation"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use dep::poseidon::poseidon::bn254;\n\n/// Veil Protocol ZK Withdrawal Proof Circuit\n///\n/// Proves knowledge of (secret, blinder) that hash to a public commitment\n/// and that the nullifier is correctly derived from the secret.\n/// Also binds the proof to a specific recipient to prevent front-running.\n///\n/// Private inputs: secret, blinder (never appear in calldata)\n/// Public inputs: zk_commitment, nullifier_hash, denomination, recipient\n///\n/// The recipient binding prevents mempool front-running attacks where\n/// an attacker could intercept a proof and submit it with their own address.\n\nfn main(\n    // Private witness inputs (hidden from calldata)\n    secret: Field,\n    blinder: Field,\n\n    // Public inputs (verified on-chain via Garaga)\n    zk_commitment: pub Field,\n    nullifier_hash: pub Field,\n    denomination: pub Field,\n    recipient: pub Field,\n) {\n    // 1. Verify commitment preimage\n    // commitment = Poseidon_BN254(secret, blinder, denomination)\n    let computed_commitment = bn254::hash_3([secret, blinder, denomination]);\n    assert(computed_commitment == zk_commitment, \"Invalid commitment preimage\");\n\n    // 2. Verify nullifier derivation\n    // nullifier = Poseidon_BN254(secret, 1)\n    let computed_nullifier = bn254::hash_2([secret, 1]);\n    assert(computed_nullifier == nullifier_hash, \"Invalid nullifier derivation\");\n\n    // 3. Verify recipient is bound (non-zero)\n    // The contract verifies the actual value matches the caller/recipient address.\n    // This just ensures the proof was generated with a specific recipient in mind.\n    assert(recipient != 0, \"Recipient cannot be zero\");\n}\n\n#[test]\nfn test_valid_proof() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n    let recipient = 0x1234abcd;\n\n    let expected_commitment = bn254::hash_3([secret, blinder, denomination]);\n    let expected_nullifier = bn254::hash_2([secret, 1]);\n\n    main(secret, blinder, expected_commitment, expected_nullifier, denomination, recipient);\n}\n\n#[test(should_fail_with = \"Invalid commitment preimage\")]\nfn test_invalid_commitment() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n    let recipient = 0x1234abcd;\n\n    let expected_nullifier = bn254::hash_2([secret, 1]);\n\n    main(secret, blinder, 999999, expected_nullifier, denomination, recipient);\n}\n\n#[test(should_fail_with = \"Invalid nullifier derivation\")]\nfn test_invalid_nullifier() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n    let recipient = 0x1234abcd;\n\n    let expected_commitment = bn254::hash_3([secret, blinder, denomination]);\n\n    main(secret, blinder, expected_commitment, 888888, denomination, recipient);\n}\n\n#[test(should_fail_with = \"Recipient cannot be zero\")]\nfn test_zero_recipient() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n\n    let expected_commitment = bn254::hash_3([secret, blinder, denomination]);\n    let expected_nullifier = bn254::hash_2([secret, 1]);\n\n    main(secret, blinder, expected_commitment, expected_nullifier, denomination, 0);\n}\n","path":"/Users/macbookair/projects/ghost-sats/circuits/ghostsats/src/main.nr"},"55":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"56":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"57":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}