{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"14665699306534466410","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"blinder","type":{"kind":"field"},"visibility":"private"},{"name":"zk_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"denomination","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"13092923600342307159":{"error_kind":"string","string":"Invalid commitment preimage"},"14561130511985968207":{"error_kind":"string","string":"Invalid nullifier derivation"}}},"bytecode":"H4sIAAAAAAAA/7z9CTSV3f8//h/zPM/zPM9limQq0SgqlEoTSkURShEylIpIkqRCipAhQpmjyBBKMqdCREUR4v893e7f/3X8vuu32+e93Get97o/a312135d+1zX6/nYdc51KAj/vKjn/3t494EjjQwEQiQl4f95Ucz/V5zwV69/hxMoF/w5YZujG4+co9qkLClldOBG0QuBO0fN2O3lUnnTp4KUbh5Ig2PV92041qtxS+Gx5ao8f3/bHfJLB8xPFLhdNu39EfX1//z/acBYheEvPad37qk0DOLdrhdlalK0xFVygmOVjl70w9XfTwtfhcUtrOlvzkX8L2uiBWNld3T3ynVuenpsmabP8XBGLvEh5epVjC9F0ldPMl9s0Hzz/xwcoxaa+fNe+OdQddH9/Rz//5PGqIti/s8sXFvKGuv96crhnxluXPquV7TGya7TrVT2GHeFLq9X7wm1LGsKjHOgB2PpTs+Vebjf2Mz28EDUmaUlKi7paye2Szro1KlcyXpfQf0TFof7fuPUxADGCsRYDq9W42fo+Xlw807RTXuM6R+cteQpTzWY0S7MjXmb+ufgmLXQz5837vvNSFjc95vYK4j/W7i2inP9M7W2H9glRVnWjgTT7Lk+cHrlrYbeuVv7R9nC++K+UmOcAxMYKxJqc3fo0Y58t5pM98Cqy6s7r/j+9BgWZneTOLLeef+m3bA43PcbpyZmMJbHb2x2/4Nj9BxstMkTppRZ6z1W3LF0+jrXuGQipPpb3eSfg2PWwjR/3rjvNwvhf3u/5TyDLTZ6riyqvJ91pZdOeuiqn8izEP6PN5d/eS6RnZIhQOxrdGTU5Uz5v9VFaZAXcrbv60umoN2hsvdzLDcplO07EaPPeDbJ6qbjwxt7iPcfIxl1Hfgf6xLRipfeJX+I8zWLo36Gu2HM+a8X2t+o8z3z0Tu+z3UsoIx4nbCQUddBzLr+fVFjzsNK+PtrEuM9pMBYVwp4rqI/pzyUfIuvBYge1Nra/HyC+0GQj9mQQGXa7drdvRcT3v75A/Njxf/y+MRzZCXgvwdshP/t2kANZ5ufA7cudsJ/c21wgLEC6nHf44VmLlUpbS552cMZK/w9105R6GEj7+QtFR6WOX94bYh6lTeoaV/7FXLAPvVCjIl600j8EY4tp1szhW6Oab9haYTXBoWEXneS1PmHwpxr4scb5A4cM7LcVbHEYkhPIolCtuZJFrw25B4YljDmyjsJfFX0p++RvG1/TbeuadWR77bUxlkUJSHX/hxvwTkiXhQc8+eJ+x5wEhb32uCcnwO3Li7Cf3NtcIOxsmqzLw9oJBVWeXjtTH4SQsVuPKJh+5R7k2KA6GeRHmZ3eG1ITw6HehnvVpX7pD7A7+bVyiu3JG0o1NnnV8/s0emc11zw2hAv1KBksbx0ori192CkxJbrzVRSEdetkl4b+rWIKgs/5ITXBu+D57WU79sPP3vz6LDQ3IfIQe0g8aLlJ7ydnq0RmdlH4/FnURecI+JFwT1/nrjvAQ9hca8Nnvk5cOviJfw31wYfGMt0bLnqNEFk7kvrkBzbtAeHvtfolQse6VkTL/K2HnoqEwqvDUVqN5sgER/KxuTU/iL9LVNfH/mJhItZZj/5sEnD2f/3a3htUNpMHre0WHZRsW6uSqBclWbKWeFVuVWSXG6hvkxI78MCeG0wanx49kHEV9RTk8JS73h1zC1qZeod6pxn9nym1N58Zq36n0VdcI6IFwXf/Hnivgf8hMW9Nvjn58CtS4Dwv9UldZhr2YpJ+8rzWiKtwZ0nRT72xZoo7Jb7HXLlmFTGJvp0Yv6yk1GXy//oM5Rnib2fi4y6Di2yZ4l9h5eMug4vsmeJ17wAGXUdIdOzNJjzCBL+/l7BuLYoMN5vCoz3gAKuCzMh7uwny09NBqXMp1+OegQmW0ddPddsWWfW/zhiy+/Vun/+wPxY8b88PnE9BAn475cQ4X+7jlDDhebnwK1LmPDfXEciYKw0j4KJ9dQbn0677ZNnqeNmhXg6PFJVlOl/1Rc6Re6o04LXEcrJhzCcfBjDyfA6ohDjzarSC9pIEau6bOu4Shj10H7mw9Y7H4obDHsU/66h/TNmwXogXhQi82uC+36JEhb3OhKdnwO3LjHCf3MdiYOxvL5Lb6y0HNkRFZ2n6JaltzXxev5EfNg36xLr+OvGig2c8DpCmfoQhqkPY5gaXkesb27u1NVzDhePv75VJPXEbjVD70azky2bg7rpGAy1j1v8eQMWrAfiRSE+Pxb3/ZIgLO51JDE/B25dkoT/5jqSAmO5l/MttT1nxajIIn+g8MNzR6F3dBdeiCcvyX1bcUPLdFoCXkcofx/C8PdhDH/D64i6/f4aH+bB9xIP0o1XK7kU6w1b+u3MaTY00z4muy7BO+7PG7BgPRAvCqn5NcF9v6QJi3sdSc/PgVuXDOF/qwvlb6IBhMmoy32R/U3MFDEy6vJYZH8Tx0mSUdfxRfY38ZqXIaMuz//I37KEv79XMK4tCoz3mwLjPaCA68JoKKvz1mjs9pGHV+SE46V8HLSPn177iGmi3l3tW8uU/MCfPzA/Vvwvj09cD1kC/vslR/jfriPUcLn5OXDrkif8N9eRAuHv/e2O4W8PDH8fx/A3vI5krju6ct78LBB+XthSrV13alnW1+Nbo/flfVxjvoMjYInhn+MtWA/Ei0Jhfk1w3y9FwuJeR4rzc+DWpUT4b64jZcLf+9sdw98eGP4+juFveB3Jl3jYvcger3rb33hwQ1+Sn9eqFjl23Y88J5f8nvjS8+b2nzdgwXogXhTK82uC+36pEBb3OlKZnwO3LlXCf3MdqRH+3t/uGP72wPD3cQx/k+Sa8H3jrzZUx2U/i7OZxw20VJwKKnr56U7G8OWnB4xNpVf/eQMWrAfiRaE2vya475c6YXGvI/X5OXDr0iD8b3Wh/E00gDwZdfkssr+JmaJERl2nFtnfxB6lSkZdpxfZ38RrXoOMunz/I38vIfz9vYJxbVFgvN8UGO8BBVwXZtfw6LCeQXXr1t8bn63iDNqi9YVn2ddNHbl6sr8j9+5u+PMH5seK/+XxieuxhID/fi0l/G/XEWr40vk5cOvSJCxuXUvm58CtSwuM5VjpbkFxT5jH9PET1xfN+39QHxg6d+XK5eYDBsU39ui2McMJaRfMg+qjWhg1aYOx7PaiNuFzTCc6A7+uDqh5ZB26vNRMc+jgPhbpluODq5dNwHtBVVqxZDvdoFmB8Zj346zLGgxnL7yKpF+qvpqXI0HXczwC3gsCQa7PGsLkD7ua+V7bpjLNm+H3icmGMTfGRGLDxYpTDa3wXuB2/HymIfZukMU3rSKzTvquX+n05dNPdl/nObq/JHO6ggbeC1Kud7vGO1yeXXpqyVc7rv5GhsanvL/zeyJXqQX9yMV2DnLeW+35NcF9b3UIi3vN6czPgVuXLmFx69KenwO3rmVgrOjc9egN0k9aMsXz0jze3hRuDqu6cr9/5913EievtZ+pk4QT0i2YR/FY+dCNqqerd71ITPQ57Lk/wTdO4Zmer8/b5BV797vWWsN7AXXfLMOoXw+M5TbS2hKsJ7Gv74rK0frkx3JR047mLAfZB7ipZjZRN1yIgfeN8sV3B4qiA/hWHVpPdW/YOmtWf7vhcPHNXbJaMjO/gr48gPcN3Y22/iCf41I5grwS4rsC+HZPqrKcGf/MoFTUG65153gCvG8oOpZRxU19MvdU0Xngfb+Ol8lQKv9q9cETkmd85Z0e0JFkCNOh+xwnq0b2npBP5uB1kPOzcmy4q8dMsTpxameN1PQPlT/HW7DOiBeF3vya4F4H+oTFvT715+fArWs5YXHr0pufA7cuAzCW2+10v8Whrbq//Aafnja3F//8pqR9hib2hKjFVKO68JtuOCH9gnnYbTdYyv0+UfzBaOnn/YVRQXkZFjSBOg5KxVajw1sanRThfYO6x+B9g7rHDDDOdQUYK1y1f3mRXxLb2uwCu3adqemDdivW2GuX2vSp2eTX9stcgPcYje/qX7KFR9aUSq+Ofz6+4m3B9rBtpu9qt5ufVfZq5xZTg/eY2qeGy+c/Ufx8yns6vGhuqbhGU2NfUkzVNdF7ihI2x2I/wHtMZoOqIadm8mdf7l+7nrHR0ukcdCFI6O0zOhup8v0y5aYceI9xb7DaRneUpeJkzy76F8paz78u29l/JqHdchfNlkh+HSetPxfBgvcE8aJYMb8muNeMIWFxr2XD+Tlw6zIiLG5dK+bnwK3LGIzlauzSFLon8Iutb1TsVE/y+iDdB51xKyaN7ouYj1g7mDyGEzIsmIfxa9oOz72fv5XOtgsw8NTdeSCQWOmyg3Or5faGF1enku/Bewx1P8J7DHU/wnsMdT8aY6yLCRirNGm154OjrfC6pTQn7qf7+42Xn4hptgoeZh9jkLAyTv0A70eVEvk2Q+7DDYpvtQmdK9q3xfF94LvsSr231t1+2xr+N2bwfmQLebhqqUb725anuw+yVN4c2Oms83Xd5Hqhvg3KoW/pXjyC96Pszx39uzbtz0hYd+qZ6l2CLUcTn8yB7QZSfT4v776Y9V0P70cKReZnkhSKwd7LDy6vOObJYKs+bdM8wa9xkqaYvkb1csmfMQveP8SLwmR+TXCvL1PC4l73pvNz4Na1krC4dZnMz4Fb1yowVtaKMauJsOVdVyvn6zg6+rO2ZeenG9/ZZgx+23SfSkfpNpyQccE8CqqvmL5QtFE6Oc6UzObs6L/3pWCfeLayus79c+bXK6nOw/sRde/C+xF178L7EXXvwvsRde+uwlhDMzCWz/Ub5/3Qy2Zn3G209vG8NXy75svGyldBnUyahRd6h0cr4b3LnjptaJB3MOVx/6D1+c+sUin1Vg6G1rm/7vBonpmyavwN712xOrM7Bxl9tltcI9yupZXzGlVYL8KmGdPHxcOU4mlScAHeuyqHz7kfudckIvra6oSPSvXUctsrFNsCBxl+Zr/0kmwqq4X3rrJByN5ww6/5XIXVcqW8Qha9B6l25a+IXXGfOcdH+8OLyD8X14L3GvGiMJtfE9xrcTVhce+R1fNz4NZlTljcuszm58CtywKMpb2QG3CyMmjmyHGdxNJbh+mTyk+w2e9vCz58XOFA7ITFLjgh04J5RJxdY8bvesqFR0/pthVrCVz0ofpO/2REf+qutGxqKqM/vHdR9zm8d1H3Obx3Ufc5vHdR9zm8d1H3uQXGeq8BY4X5el6enFwdQsitG9yu9tq+0uODr4e9hHrrWf7KjyFZnfA+Z9F0sr1fZ3NU2N2wZvqeotNmzm/rWRzGL37ULOnc5xtWBe9zpdhXvjYRoU1t31X113crWEXQ92hYW+6h9DyROej+cqwf3udiibSnP35Y8ulpulLB9B36BytnzdONqBKreQ+s7twj3kjy9znChza9yb+euikq5Nvsc8mIVI5zojRLf/OyXXIbE4jXl1/y50JccF0gXhRr5tcE97pdS1jc+2nt/By4da0jLG5da+bnwK1rPRhL96YwVdX2lMRDgynWfA7t99eUc87l6j5/Ii9n3vjJY+AmnJB5wTxsPndvfvUya6gtPmtVW/Mts6inhTeq0SPXg3lgUCS79Rq8z1E9Ad7nqJ4A73NUT4D3OaonwPsc1RPgfY7qCesx3psNcB2cx7U3q99bri22VromLr2K8k2fD1WsfFXgMpaIW0pHn8KewPbQRW88fMmVmRqb9Um/+yc/3+xP4LqzRvGzW0uMFXXSe5Ke0Ljs6TK6Ww5HH9RFbza4s37s5b4b8ZTs8tmbaD5v+j4sD3uCQGpg+fXVc6Ir2na9vB74bajaRHIgPerGeUnRzJGWgXhB2BPUio97x6S8TQ56yLtuSO5CgX2R1k22ywUpzAd3uBY2mVX+uWgXXEOIF8WG+TXBvcY3Ehb33ts4PwduXZaExa1rw/wcuHVtAmN5ClS02ylreR9rjKSpHmndwek6Xe7xcukeHfpNVod7DeTghCwL5hHoHuttWsqQzj6YKK3ykv52e9voTjOChLVqJO3B9Rp3tWFPQPUP2BNQ/QP2BFT/gD0B1T9gT0D1D9gTUP0D9gRU/9iE8T5agbG8b/Zcl5HOOh5ygqOisT6a+Vltg4q0hcFvs7ZloX3PWh1h/5AQTS200t6YOFRXT9GcpiR/fVts88bH3KKey2LbrdtKGGD/kP24nDNF6Oz5V48VBZrP0gpmZPV+Pr39dNuG8tCNArOlUrB/SI8UKcdURVKff7r8pOXnZ8H+4y6pM+/3J51bTsexSZu9BfYP1qQLoXfEeKWPc8al3LBnLJu8W0qZolrB+EV3kLrgvgFZ33m1ml8T3PvBmrC496n1/By4dW0mLG5dVvNz4Na1BYyV87kxcHlpl88J/vRdDWnuUqPbbwjwPgqt893G4r/uydJoOCHrgnkkJMQuRrisk0+LtGZ95Leyhc31c+nkQ7aTeX1mCoRJTSXYP1C9BvYPVK+B/QPVa2D/QPUa2D9QvQb2D1Svgf0D1Wtg/0D1mi0Y7/lWMFbtR+2xFaab/o8MLh6SbXeqKHyyVOd7ZIq/qZHz44xhsXrYaxiSVjPZPmRrfKHZuubolL1NuY/b0rVzX6P8v6k4ssV90yT5O8agdWlWO8JyHG6fVQ9hl6wpFeNz1njZG3Nj/BxV8bTUGthrFBw7BKSTZ87X+r5Tj8nXErygwUkTr0JxJP/O9paC7smdsNfQ3R/e9kRRQsjzabOl3RuKqsl3bbxv9x76LON8oWDyoGAjcQzuvbN1fk1w7x0bwuLe0zbzc+DWZUtY3Lq2zs+BW5cdGKs4sDrPZfkO93wmd3Wj1OBnYu5ukW/sNSNfKxDYbp9RkoYTsi2YRzLya9GVDLErHVb2zIJP7JTkTk1yKX4S4nrwePbzsQ+JtLDXoPoS7DWovgR7DaovwV6D6kuw16D6Euw1qL4Eew2qL8Feg+pLsNeg+pIdxvWxDYxlISge/Hhh5+GUE/bZ2WJVcjfp7pzXsqTujJ361mu0+mkkyb991JjleqXkBmr8es1zf+XrQx3TebuzAw66XlZyfe4zmTAK+5JkmcXhqBG7wwVhZeIB2u/PKH7bTMFIfyEzx89kKK2b/xJJX3rnIjwam8V3jamYNvlcF+uaJ6/Or4wS2f01WrKreKPlXpLP0r31PJZ5hubOkVF9wYszhYHMMTxLtVJyzKdPrL2oEkr/53l/uPfZtvk1wb3PthMW9/7fPj8Hbl32hMWta9v8HLh17QBj1RIHMsRGY9Z1vUm72yHTsNWXtydT4dNxN0fT70KTo282wQnZF8zDvlJz+LqWSJCunNvLsSI928F9xkuiXuXVbXzpcX/dh8gR2JdQPQz2JVQPg30J1cNgX0L1MNiXUD0M9iVUD4N9CdXDYF9C9TDYl1A9DPYlVA/bgXEt7QRjxdsP6oYIcfeGa4u6EfauXDZ5XKmqcaw/e4+5omsGrcIUyedeI6vqwi9znM9Io+g989zshnvdNb2YLeH2fjvyogrZTzyFPUxca6t5AGdK8vUgyZPfPRpYJgRb2S9yGayZC3HUWs8d4ELyd8NbnALtWMRG+toe3DDfv02Q0zm18cbhuNXmt3iCtBl/y5H8++1dhbOmrZVuU+1ndnk7sE+aG2//FMntJmckfY1C3/7T6T9j/q2B8Fcvip3za4J7T+4iLG6v2DU/B25dDoTFrWvn/By4de0GY5lE1kbT11e+up5suGHW7NkJq/Zm55knLZvvZdH7lJ0XD4UTciyYR3TF4SdvUk2ohz33Uca+mnk5GeHzXWL5mvG6I/fMr60wOk7yeQpEv4M9DNXvYA9D9TvYw1D9DvYwVL+DPQzV72APQ/U72MNQ/Q72MFS/I/E0ot/BHobqd7sxrrs9YCyFWSDvg4tXx0V8u+kOZYVvfxJsuyEu7dGuvKSZlvsTqqWw37HS+Mb/7F3fUiYuYFIe2Zk/M3I241yRBOcFu/RfOQ4BIyT/5u0nRruaq4EqzWNJjrSiyL33tZevGK14caFxI9vWleH7lsN+p1jGEur0zGTnmKC816VXTz9Vj9RYqocNMCk6nnKhpzHQIfn8mB2ha/JT7MxGbY2aiRvxdOFXs8Ikmikcbt1RnOFJbP0zDPf+3TO/Jrj3717C4vaVvfNz4Na1j7C4de2ZnwO3rv1gLGWzP8V6Cpuw0LAl7nJMaR3L9Coi+6PDelafWz01tTXuIZyQc8E8bOmrcu9cM9j98ekKOY5fask7I/J+L03x3vm9+dC5IH8bkr+3QvVGks+rIHoj7Heo3gj7Hao3wn6H6o2w36F6I+x3qN4I+x2qN8J+h+qNsN+heiPsd6jeCPsdqjfux7hGHcFYXoEM3w9P39iP7NZRfO5A33ZQjb15SaD1Kp6DOQ01QXQWsDeqS+0IajvEFHbw5tJkjweOL4yzN54aoy74KeX8scwm9chdkv2sSYvFmyYbiS4KFqcfnEzvzUzOqv96tj+kc6mJf6aLYC3sjUp5Vbdjv6yseqdzrsjGJeOyx71rOhZK5bbbqPfQfK2Oa4e9kWbMd9WckXHbkmie2+2ja3S+slYu/3bcNdB/W7oG4+BN4qP9sO91x/k1wb3XnQiL24Oc5ufArcuZsLh1Oc7PgVvXATBW9cQ9ueebaaVlpO6v1CC4STwJ3raq5kmhqXOlyMrg2dnncEKuBfMwV+sWTd9v+kEr+ebjxYzcjg072cRu8zf9buXU7xtdE2lK8m+CiD5K8l0URB8l+TwQoo/C3ojqo7A3ovoo7I2oPgp7I6qPwt6I6qOwN6L6KOyNqD4KeyOqj8LeiOqjsDei+ugBjOv5IFwzaoXp10Iemznsr90/t6P9RWPpfoNYpqonp75KnGHrs98M+6hitKhlpW7Qzuti/EmMmUMDRp6EL+M8d10VrXeOSna5boZ9VKp515Zku/XbTj5X+rnOY88hl00CMvnlSgYTu4IrJfzPK5MYk6ZRKeZ0/tcxRY+RmcmBw/c/GtxsIZzocTxtxTtVR3uN5N8rTn0OaXP3tvUW5BxXG3hAUWB4hOYTlfHVJWleksF1Gq+IY3D7wsH5NcHtCy5/P8c/Ey04Pmq4y/wcuHUdIixuXQfn58Ct6zAYS0n3Iu603Rr73a2fmMu17dcxn1nXoslw/qf0RkZCuV3Oajgh94J5GMZ9PuVOrauzC0njilvTfPlM9+VN77Sou6ZuqF5giP/5G/ZRVM8l+bdRRM+FfRTVc2EfRfVc2EdRPRf2UVTPhX0U1XNhH0X1XNhHUT0X9lFUz4V9FNVzYR9F9VzYR1E9F/ZRVM+F1zPyOblgLJVx3FYXIaUTaS+CfoTT9dO0+IZ0up34Ip7xMnHz+ve3n8GeKxCiZ8tFF2NacFG1YvxNo1virY/m7MeV+deKJ+3/pe94EfZcwYyly0S2cbWF1h1a0f/L1jmC3+fR3kyR6PG4Lxn1gQ9I/i2G8Smd/4yrqv3LYnq3/Bs7ltG3bqLfsbXE1nFKgraSbgcDSc81cjj2xPVWkcfPpYdUWeIGpx9o63lkO/Bs/aoVda6o58/X9HB7yJH5NcHtIa5/P8c/Ey04Pmq46/wcuHW5ERa3riPzc+DWdRSM5bjBaRT82XbosSH39z1VUSamDoO+rrmKA3Yu6cU321Vq4IQ8C+YRK129zvDzmZ0HD9+ZWGexujSVmXKYIGLf8+43U8fyTaY3Yc9F9WfYc1H9meTfiBH9GfZcVH8m+Twboj/Dnovqz7Dnovoz7Lmo/gx7Lqo/w56L6s+w56L6M+y5qP4Mey6qP8Oei+rPsOei+jO89lH3yTEwlqPZNEvVtCuriOLrgKXDkynLgtsMH2wijEVDc/j1a1fMwv4sZ3VlKEnK31Pz8O/XGzZQENYKUI03nFtV+zSpZHB1Vr0C7M+8W4w+6NTpDK7P7vFp2VBiI8b4UTHep+D3XSW9HOcjETKwP1O7xf/aN+tgr/KouGUqhsl2J7fPVXvLx1Gy3GF+nk0h4SR/73oyZTK+4YlN3oezZvotScP68gP20u6t5Rm5ooknw2WSiWNw+82x+TXB7Tfufz/HPxMtOD5quPv8HLh1eRAWt65j83Pg1nUcjGXfOHahho3At7yOyflp+62EZ6ZfPSasn14yNgzUnAy5Q/Jv5bwL5qEP66D8ubZqpv3jWr2OAHWqOy737FjaGfqFn20d0XkteAL2Z1Qvh/0Z1cthf0b1ctifUb0c9mdULyf5vCCil8P+jOrlsD+jejnsz6heDvszqpfD/ozq5bA/o3o57M+oXg77M6qXw/6M6uWwP6N6ObxPkM/EhdfOl3K5MZqgvW77Vrw8EyZ+7dQ1f/rtPPmxs19HvC+0jzCTfHckVmLbT59PS+89CvkYEf5O4rQio5K+daDzmOKcgYze2GHYy2mWOix5Z6H21KT795ffH0vufGz6xbnDqWhw99zvnfu89pfCXs6ikzpx2/WhNVNscfy7xFMiOoO3dZ/f4qSdGpV57W1X7wl7OW+A/Co+nq57F+7LcXVnBA8HPx3lqK1ru1gcX8Qh8GL2PXEMbm/ynF8T3N7k9fdz/DPRguOjhnvNz4FblzdhcevynJ8Dt64TYKzadmuvpzyu587acgzJSmvvvViq+7iWvXf1vdPjpe91TazhhHwL5hFv77f9+lh9Lc/OsBFXhkrm9fQR8lEHOz/MMnKsN9yTEgx7Oarvw16O6vuwl6P6PuzlqL5P8pkBRN+HvRzV90k+j4no+7CXo/o+7OWovg97Oarvw16O6vuwl6P6PuzlqL4Pezmq78Nejur7sJej+j7s5ai+D+8p1P13EoxVe2qq+2P54Ksn41z7axt2+jkcmblG8VG+sXXnmaNN/o09sO9TLNupfDzp4L2KwfvPa60ZlF2NXg28zznOU2ibms1+q2kv7PusLPKadZMF4lQHhz9/WskwvK5gOP2Rzxa1lo/1KuoHzpyCfZ+ecdWtzQUzo5yi/kUnJ6iTKToTzlMtDWqwsyyUDt5vvBH2fcrjJ2fnlsj4Gg9mSl6jeyjRUm39aLN//aHQSv0L/+c0yfoc/sn5NcHtYz5/P8c/Ey04Pmq4z/wcuHWdIixuXSfn58Ct6zQYy+Y20KMiInX1nPq9nvYDWeWU1GN9ufV17GL+qw8z7bxP8jvl/AvmkaqK//zzbI2PhPznpw22q7/dlzw9lTYxaSzn9qTNJHHsAuz7qIyAfR+VEbDvozIC9n1URsC+j8oIks9OIDIC9n1URpB83hWREbDvozIC9n1URsC+j8oI2PdRGQH7PiojYN9HZQTs+6iMgH0flRGw76MyAvZ9VEbA+w/5vF4wVj5Gr3xzxJITHEH26dl3feLFzUJe3A3zkH9sfMffn7LJBGYE5YnxjxPPHEqKbU9n/Rjv2CZ+nIl1+JJaof1a/bmYH51OJH8Pf3dsg4LbOkpDf79xllG1jQ+qfz854WO63qlCju6lwvXjJN8Lre19qC3+cXlvm2zoHnWbh0sCOMp5ujpkUuWv1xx5eJ8NZoS0iWiODbvEil0FxzOW+JVRXv9wxihK+ImWgrbV8udUzX+eRYLb83zn1wS35/n9/Rz/TLTg+KjhfvNz4NZ1hrC4dfnOz4Fblz8YK1i5X28TnWC/5C9Gqq+0b21sudu9lfwEftK9+/D64OvgHDihwIJ5mKq+lVZz9W3OJ6j98HFuu/DZ/eTWGc6Uxpt6x3VWcwhGkzw7FJEnMCNQeQIzApUnMCNQeQIzApUnMCNQeULyGRJEnsCMQOUJyeeJEXkCMwKVJzAjUHkCMwKVJzAjUHkCMwKVJzAjUHkCMwKVJyR/H4rIE5gRqDyBGYHKE3ivou7rADBWqeZoceNkc5KvbC9X58mX1091lAeec+F8lKDl++6HioQxzBMhwetuVQfqbzJMrh1k/E6j1Z3FZvSxaYZNV3KV0oCnKMnfNbEet+1Wt5CXdD/+47UAd8U3k1P0O+lt0mrlOtwmmbUiekm+Y8d/dy9LeZ7uxJi6yOsNE4ovfSbetiZf5L+Z8OFuGC2bOcwThT7pax4/mDU4rCZ3XVAJd/xK9X3dE/vLeRxGHZJvKr+kEcfg9seA+TXB7Y+Bfz/HPxMtOD5qeOD8HLh1nSUsbl0B83Pg1hUExnJmyRL6St72P536OHpjoy7NlHH/mpqS0wN8Aep897INCuCEggvmYdJ6FuszwmMvEC0qIbY5VOE4fcxWn6ag+iKuxHL9uts5ME9Q2UPyTF1E9sA8QWUPzBNU9sA8QWUPzBNU9sA8QWUPyWdpENkD8wSVPSSf10ZkD8wTVPbAPEFlD8wTVPbAPEFlD8wTVPbAPEFlD8wTVPbAPEFlD8wTVPbAPEFlD7yvUT0gGIyVFlQ5cPti8MvIDYxcU0ziZ5f3Km14vU60LeFbj4Ftvdl6mD3cZ9uYN1ccc7RoPcq6do33bQmBykM5WwQuC3y7zXaVtm0Zyb9z8EX0FZvWyzM37wtVSncPUMk5s0sgecm1g2+Z1p2I0mUj+fuuJdk1PZte+4/X0r7sSs1p3zxyu+3atpVnX64/usvD12AZyTNuioI4Hw89uPtOes7yyd6faRJWVnSJBQYy3Qzp1k/jb/YQx+D20uD5NcHtpSF/P8c/Ey04Pmp4yPwcuHWFEha3ruD5OXDrOgfGchS8iqW/HP8gv2eysdBL/rDxcYXb50XOVdJ8EVaXT+iUhxMKLZhHrCR1fXPXz7nKKZVdHzM2X/J9MqVVXZ2w7vSO8J/Tj3lIfnsElVMwe1A5RfKsaUROwexB5RTMHlROwexB5RTMHlROwexB5RTJZ4oQOQWzB5VTJJ+HR+QUzB5UTsHsQeUUzB5UTsHsQeUUzB5UTsHsQeUUzB5UTsHsQeUUzB5UTsHsQeUU7AGofnEeXr899ezpFYyh5vlX5NbeUXrN8KNDRGvl5Vsqih4MErdrGUi+w69DYZweWalkZBqs+MriWfh60zfbyi582c8scevZqWjKTpLfHVn9xIg2ijGU7kTPHdMaN79itW+fqw4KKdrUpG+5o3L5CMlznAXZPvYvr35Mue1tqWeb/Ni0EK/z7WTzgfIDqSkTpk9kST77aqB/R3xw7PGR27zLhHn8OayXeFgZSiSvDNtCOCJNv3GSOAa3756fXxPcvhv293P8M9GC46OGh83PgVvXBcLi1nV+fg7cui6CscpaLNK7Nh4PXr1y8mLJ5OzS7YTxaefQ6DJtPY+zDwbEm+GEwgvm4bb/WCgfOWhE8K6tsAzak/A2stjiVRNVyeQDXoscm9fcJJ+tQmQaSU4hMg3mFCrTYE6hMg3mFCrTYE6hMg3mFCrTYE6hMg3mFCrTSD5bhcg0mFOoTIM5hco0mFOoTIM5hco0mFOoTIM5hco0mFOoTIM5hco0mFOoTIM5hco0mFOoTIM5hco02C9QveUSGCt3TWN1d+baIJO8wW/mmsfsXBQvj2numhSZVNB3L3G1t4aZxqj5ZFnGrTDJovvs+zTOZ5vTuj7x3nONyzqad/ejg2ecsmCmMfvX6G33TrHs+LrzxGMjShnB5Ic3PC/f96Tcr9geUdo7CDNN8ONTGfFPDaGcT2vWpU99Lf62bTbN483g+XraTdq+9xjtYKYpPTc4L74qybV9Zc+YaaUT03FHsUDXluYTBZVy2lm5LV3EMbg9+tL8muD26PC/n+OfiRYcHzU8fH4O3LoiCItb16X5OXDrugzG8qZMuDZlc5/OG71SruxdMhHQxTfq/lElpTvAwdBEyUwMTiiyYB6GvT5VVRZGI11tG77r5TvZfeYIieO+puVwoNH3EgVnTivMNFT+kXzGDJF/JJmGyD+Yaaj8I/ltAkT+wUxD5R/MNFT+wUxD5R/MNFT+wUxD5R/JZ8wQ+QczDZV/JN/nQOQfzDRU/sFMQ+UfzDRU/sFMQ+UfzDRU/sFMQ+UfzDRU/sFMQ+UfzDRU/sFMQ+Uf7C2oPhQJxrKYqva/criwbffZlZQHV62oLMlLraDQWbXlvvVcs/eGbimYfwrCDKWXNV7QXhcupwnWdxYL0mR6XMNytfBMGEPOjTTFbJLPUVxd/jp1Ov6F1+sjNve9150ssD7p6lMRoGiYbhW9hM04jOQ3WLW+izzrSJXO3cJPt0Rwz7Hmjh8+euyHKBh3jt4461/ygORZHExsiW3MT+IGUhPO94Stv5ygLCsXSs9VbUy78nTzTANxebH7eeT8muD286i/n+OfiRYcHzU8an4O3LquEBa3rsj5OXDrigZjRfjfUq7tHTxSvlU2k/b2sp8MWqtSLY2Wvqt+H/TqpUFOF5xQdME89PFV4TEOq3YMN1B4rhmyLv7yfcpRJDjFrEtHLNbgiacDyfcZEVkJ8w+VlSSftUNkJUn+IbIS5h8qK0l+swORlTD/UFkJ8w+VlTD/UFkJ8w+VlTD/UFkJ8w+VlTD/UFlJ8n0ZRFbC/ENlJcw/VFbC/ENlJcw/VFbC/ENlJcw/VFbC/ENlJcw/VFbC/ENlJcw/VFbCPoTqWVfh9Ttz57JD3b3Pn1e/baaLsNNYGaQTdiLPvG9N2yFKDcdMBZLPpS+V3uihbLbiXPhBX/oh+ZQ3/syUhw8GVTWeTjBm8fOvg1kpEzxAI6td4HSgMLPX7N2VrYKvGtU1vYMGVEV2sYQ6bxQgeYZpwZeRmf1nkz7v03Boj9epvq5iR+ceda+iyyvpknnoPhuYlSLrC0v00pWjtbziOfiLtk4s22hr2qnX7zX3iUOX7mHcn2G4vf/q/Jrg9v6Yv5/jn4kWHB81PGZ+Dty6rhEWt66r83Pg1hULxjJfSBN8HXvm2JXtcaGS4dbl0WbOAtNX3v68/2Vl3MBE2QU4odiCeZRs7olNZVOOlNy++e6ySW6U3x2pLUM1r/s3WOeJ5D54RfKbsKhcJfluKSJXSX43GpGrMCtRuUqSlYhchVmJylWS37JB5CrMSlSuwqxE5SrMSlSuwqxE5SrMSlSuknzmEJGrMCtRuUryfSRErsKsROUqzEpUrsKsROUqyfdCELkKsxKVqzArUbkKsxKVqzArUbkKsxKVqzArUbkKexaqv10HY5l2iRSqGAWHfxwacAy1uNkX/X14aZW2xbXedSpv1ec8JUn+XXEr7VMDjmdZxQ0KTxWlTDQUe+hYbzXqpYpHxl5QWfXbAuYqgT5d483kO4YSQXbaMYF1Dt5vHvZKW0V39laes7JXXs0Lc1XqeMLu1DtvfF1St+fmKMiU7H90ZmWhr0ZIb4zp9bU8DI9grgruiPb65OvLN1ftun2Z1uYGqn3rlvknSLaIcb38uc7m/p/fFsPNievza4KbE3F/P8c/Ey04Pmp43PwcuHXdICxuXdfn58CtKx6MFXR+tbSVqs7oUCLB+PLyPpPl7llLz/KfzLKmYMjfmr7xJJxQfMF/CcnnowIP2O4vvrVxLW3TptHTKwQErP3Xd3Y0GW4eChdThbmKymCS73shMpjke76IDIa5ispgks9eIjKYJFcRGQxzFZXBJL/xhMhgmKuoDIa5ispgmKuoDIa5ispgmKuoDCb57CUig2GuojKY5PteiAyGuYrKYJirqAyGuYrKYJirqAyGuYrKYJirqAyGuYrKYJirqAyGuYrKYJirqAyG/Q3VC2+CsRQnmnY5pT4sTuw4VXaAic+a7uvYF+6nAh+9VfPrHeroW2EG0yzpUT6kxZzb3q554QFvPcuuMAFHaZ+K5WExbIJvvcq/k/zO4jLqDrPrWo2Mxh9pe9Yc8Fp54HAzx1wOo4HxWGsb7bgBye+0jtzWeqo8vn5pbYxK98vbjy9z+dSUHlhCtdxqIEH3+e5Mkt/nUKD8qnCZqfuItNSqp4qarS9D02gqfle8Xad+63dyZofSnzHzY//9M4gXxc35NcHNlIS/n+OfiRYcHzU8YX4O3LpuERa3rpvzc+DWdRuMlU4OuxlcH2A4XmltcoWbb06qcfmZma5fFhduvXUI2klxH04osWAe0XXLd62udfvUoFObav+NyWOZcEefre5u5lyzMIeYWy9mYQaj8hpmMCqvSb5Ph8hrmMGovIYZjMprks+gIvKaJIMReQ0zGJXXJL99hshrmMGovIYZjMprmMGovIYZjMprmMGovCb5DCoir2EGo/Ka5Pt0iLyGGYzKa5jBqLyGGYzKa5jBqLyGGYzKa5jBqLyGGYzKa5jBqLyGGYzKa5jBqLyGvRDVN+/Aeo1Y2yN2cdwMqtzUKOEQO3Pv+K8Rhb1m22Z/11RTnk1zg3mtlr1353LV/Nc2dOsuPuZk7WEXF5VUdakej5vw47YOHJeAea0w19b0k3Mlz/Z7yd5ylaPesyMtlA4fh16f+TYuox4YngXzmleq4LLsodaM55lLTdaZMGUW1HvetT9zJVw8bq+ky/PeOpK/i26x0fDbk5nxO7tCm+NV5ESRu+/EpfTXj7dd2cvucZqd2M6w8+fO/Jrg5k/i38/xz0QLjo8anjg/B25dSYTFrevO/By4dSWDsax7eV4YFp1rPiPBHXZIawlbflSl8EHT4DcZbx7MqkUr28AJJRfMI7Xy9m+zF20l3JbOGtfenaL7eP3Cnb6Dq2MGVQ7e6VxBTfJ9RVS2w7xGZTvMa1S2w7xGZTvJ998R2Q7zGpXtJJ/FRWQ7SV4jsh3mNSrbSX4TEJHtMK9R2Q7zGpXtMK9R2Q7zGpXtMK9R2U7yWVxEtsO8RmU7yfcVEdkO8xqV7TCvUdkO8xqV7TCvUdkO8xqV7TCvUdkO8xqV7TCvUdkO8xqV7TCvUdkO+yaqx94FY1X7xTK5BC1P3aDkGth0NKqvcOWQ5cXsASbnYJmdKyaXiMFsZypbO5bMcsXu98XwN9/uLWV3fnvxoUq/CesT1oyrIiV0ojDbqeojtad8L354bjkdxaDjpecd8q6Ev/hycLj4to5nXCW3SLJ9tu+wnrpm3T6zTfSaL53stB6bcUmJBCRcNom4bWpTKkjyDONVe6S8xDmq296ZWsxKbf9+yGeU58i5jbsmepjoyjpiWoljcLPq7vya4GZVyt/P8c9EC46PGp4yPwduXfcIi1vX3fk5cOu6D8Yq69K2XT9Qv1fhZojrLokLx6LfHpM+seO482vbA0c0qyIn4YRSC+ah/phNO37M+QEvrXwDc4GTk2ja6MSa/f5PxG3PVVLa6K8lebYNwgEkv4+EcADMdpQDYLajHEDyfVCEA0ieRYBwAMx2lANIPpOMcABJtiMcALMd5QCS38pEOABmO8oBMNtRDoDZjnIAzHaUA2C2oxxA8plkhANgtqMcQPJ9UIQDYLajHACzHeUAmO0oB8BsRzkAZjvKATDbUQ6A2Y5yAMx2lANgtqMcALMd5QDYY1H9OBWMlZ0LVK0K3/D1qdayKa+H9BIP7w7Fl3rSe8l4Z2g8Dg2dJnn+NTWL5fKmfTN2xV+PjDIFFZbaNNxttHQqO3vmFsuOl7VqJN+31b89/OzSTs8Em2j/w2k/uiNH0y9+0ZjbyvfF32rwLC3pb2Yf0g3N1qjMkc9PuP7Y59cmnz0rDVVqH1BmBphbd2i79ZE8466Bcez58HfH533Wdo9fpDB80tsh3ElBrRH9gONjpvUlshyQOr8muLmW9vdz/DPRguOjhqfNz4Fb1wPC4taVOj8Hbl3pYCzNjXN6XqJXvNZbJG61WOXcqeO8Ne2c2445mfYA92C2WxvghNIL5hGI+76mXNTXvELejOlgKNVc5zaz52eZ2zSZ8zUitWnkdaADUGYgeSYRwgwkv++FMAN0AMoM0AEoM5B83xZhBpLnQiDMAB2AMgPJZ7MRZiBxAMIM0AEoM0AHoMwAHYAyA3QAygzQASgzQAegzAAdgDIDyWezEWaADkCZAToAZQboAJQZoANQZoAOQJkBOgBlBpLviCDMAB2AMgN0AMoM0AEoM0AHoMwAHYAyA+zHqN6dAcYSngce09t7ifn+yBbF6CUrg56dGrfvqxO9qP64d9cS4dFUaAbq9jNbT0jKG/MwFRYtpSo18m0JPLL6DBdljWa9m3Nrrx80g3gk67f9fU0JTNL01j5i1BJywXd4VxJeP59W3e2aNnzmFzQD/7ucy+bSX5JEPB+9qt15gk5AXZC2bObZNXHq7l/B2dNj0AyKor46Vpu9XGytfJfFl+8r2dd5VtlZN55O70Z53nKPS3+ep4qbgRnza4KbgZl/P8c/Ey04Pmp45vwcuHU9JCxuXRnzc+DWlQXGcji2+d/YmDpwTdK0sStrMsZN7vXLrSVW9bJMwzvlBh7+gBPKLJhHrPqL5YsM35blA5eYwnePmT18/ii1dEDTaKdFXmSpuboxNAPKF9AMKF+QPEsK4QtoBpQvoBlQvoBmQPmC5PvMCF+QPKMD4QtoBpQvSD6jjvAFiRkQvoBmQPmC5LeVEb6AZkD5ApoB5QtoBpQvoBlQvoBmQPmC5DPqCF9AM6B8QfJ9ZoQvoBlQvoBmQPkCmgHlC2gGlC+gGVC+gGZA+QKaAeULaAaUL6AZUL6AZkD5AvZuVJ/Phtek3vRTq7Nc9Xzmp8SSPE/q6SRo23Udd34Q/DnosCnN1u3QF7SKG2X1MjJDtlcwGxyKNlezTOP1fpDquGyj2/M19MsZZ6Av2N+/i/vpS5HxY2J5xMjw3RmDhPxsO2cPvsP0mxXkAx6YQF8I1/M9Mz/XHmFGoLIbVrp66sJE31ll+mT5U/z6Fz7asQ9AX/BkNsvKUNyero3h+8T+Q+DOlqlI+rKc7k2KpnfHzTUuGhHH4OZl9vya4OZlzt/P8c9EC46PGp4zPwduXbmExa0re34O3LoegbGcZ1zTDGsZZpROGB1aLr7cYv/MMTsOxe/sppy91u5yPYlwQtkF89Bftfs65WOtXnaI8xP78gBFhpZB65/flGK1HxX2n1qqO0zyDDCERaAvUBaBvkBZBPoCZRGS31dEWAT6AmUR6AuURUi+L46wCMnzUhAWgb5AWYTks/oIi5D4AmER6AuURUh+cxxhEegLlEWgL1AWgb5AWQT6AmUR6AuURaAvUBaBvkBZhOT74giLQF+gLAJ9gbII9AXKItAXKItAX6AsAn2Bsgj0Bcoi0Bcoi0BfoCwCfYGyCOzzqEzIg2sm/oG1JrPlnIhQgZVYz6Oc71ZxOi3Pv7yeeJPZefhlygVoEbFOUyrfDAmdO27nuWMUP52iTtwxxeIzdih7KIwntWX8BbQIm4qdwI9w1Zl1/h8ql84J3aLvdsrcuPWQgmFqYPis455z0CIM27+M3KqttjmgOX4/OrwqqP7160CZiYfbWqQnUtrTnnVDi4ilTLI9rLvVfjGDteg078tRo1uV91YqyDwMe2yYL3/Y4s9n53CzNW9+TXCzNf/v5/hnogXHRw3Pn58Dt67HhMWtK29+Dty6CsBYPnGenj4dbZpwh9SlAyoGrQYVn98mXOtqbE/c8VIk7J0ynFBuwTwclI8Oadt6NcmE+q0ayNzIIOWpYv1Ap/jmzankmRd1Znok38dHuIXk2W0It0CLoNwCLYJyC8mz2xBuIfl9UIRboEVQboEWQbmF5Pv4CLeQPLsG4RZoEZRboEVQbiGxCMIt0CIot0CLoNwCLYJyC7QIyi3QIii3QIug3AItgnILyXcWEG6BFkG5heT7+Ai3QIug3AItgnILtAjKLdAiKLdAi6DcAi2Ccgu0CMot0CIot0CLoNwCLYJyC8wEVH4UgrHc3+wTmAZ976e6U6TJF6cmKO2qljz+JTTFilFVbE966Qh0C8euhjvJZ/lWd5df2PvdcHDfFtahvb1JNxP2BTd7apkpvoNuET0cWXpJb5WJVBKvsf3Hn5/U3alKt3oUv+gLUojb1POZk+TvUBrt5CTvlVC/fxCqtfPlRf/ZnivdDjuZ2r7XCrSVnBgi+V1zCf3tbOxZpvdKlm8QuHhYXdO05KyHCoXqp4N1slcsdgu/I47BzeHC+TXBzeGiv5/jn4kWHB81vGh+Dty6nhAWt67C+Tlw63oKxtL53A4lvLVqTNzolnHht/OtMwouv1pOChl1+bq+WabIog4nlF8wD88bm4+nKF+vMYgTKTfPW8E0F/9Y2m/npys7NnzZnXj7XAV0C8o4JM87QBiH5Jl7CONAt6CMA92CMg7JM/cQxiH5fVuEcaBbUMaBbkEZh+R5BwjjkDxHCGEc6BaUcUi+u4EwDolbEMaBbkEZB7oFZRzoFpRxoFtQxoFuQRkHugVlHOgWlHFIvruBMA50C8o4JM87QBgHugVlHOgWlHGgW1DGgW5BGQe6BWUc6BaUcaBbUMaBbkEZB7oFZRzoFpRxYH6gsqYYXjsHXCIdfVZf1jy55m5ug8Or88u2VT15N/77Y25QD+GI5UuSz6EopZwSCTT+HJpX9btFd+vO0zvqJAu/9rtmfncV2jx2iBYahzL8UvWTR02qqpfL1qw4SSv6Zu2LfvqWNAFLurTN37/kJELjME5eZb7U05lFbcFj9KJTTDi3X5AicY6mOIj7wu3W/cvfk/zdjEiXi7SyaUVSavRNJ5c99N820xnJizw69f6cCI1p24l24hjczC6eXxPczC75+zn+mWjB8VHDS+bnwK2rlLC4dRXPz4FbVxkYK35luNW55N7Xbhbvxjaz3szxO82XKG8ar44/spytP+Eeye9pKiyYR61exWnmRaLu3aJzRjfbKX3PfTB/mFokbCwvdkh480r369A4KA9B46A8RPI8CYSHoHFQHoLGQXkIGgflIZJnJSI8RPL7zAgPQeOgPASNg/IQyfMkEB6CxkF5CBoH5SGS77AgPERiHISHoHFQHoLGQXkIGgflIWgclIegcVAegsZBeQgaB+Uhku+wIDwEjYPyEMnzJBAegsZBeQgaB+UhaByUh6BxUB6CxkF5CBoH5SFoHJSHoHFQHoLGQXkIGgflIZg1qFwqB2P524dt2zT49nT6J9PtmNghvmx1cZxAm0wXc3IC+xNKkRDoISkfF88HIwMT26ylprnZu5M6jK/PPD9gukmjSf3lyvfyXtBDQjUHAg+YTySU2Xvv55HWp+Nd/jv3bOqzprItO+LV8vpjoIcIWnvcEr8XnxjXpY4+Wkqz8jq19+E8px+ejhpsvvF5Fyihh1SCT3e6nvq2v1w29fS5qYcrtozOfmndLnVRjZPdbeShzZ/nMuHme/n8muDme8Xfz/HPRAuOjxpeMT8Hbl2VhMWtq3x+Dty6noGxzPVP1RVnz5azTXg0l/20rDnV+ORWWKqorMj96pWCAYbn4ISKC+ah2MQYUrCFhe7jKoeEmOmrt6m8zu1yuCd4wiJX0XTdMgIv9BDKTtBDKDtBD6HsBD2EshPJMy4RdoIeQtkJeghlJ5JnXCLsRPL74gg7QQ+h7AQ9hLIT9BDKTiTP10LYCXoIZSeS7/Ig7ETiIYSdoIdQdoIeQtkJeghlJ+ghlJ2gh1B2gh5C2Ql6CGUnku/yIOwEPYSyE8nzOhB2gh5C2Ql6CGUn6CGUnaCHUHaCHkLZCXoIZSfoIZSdoIdQdoIeQtkJeghlJ5hLqAyrgucWbZdD279/R6Stacb5MuEQJc4kye1GkgXtjBLBbfJHX5D8RpVY/7nXb04eTFR2oK4sKnGJL/9qNsNoXcwl1ZF2YB8TybNJxUJHKVcoZ9qoxrU1fdXtfJiSmzq0gVV79nG2haxybP0EtBOFxIp7myOr8o68fKHNrVtsr6oo6LVMRamzg5kjltky6Dq0k5S3QdipD8uuzEgt0Zbja34nfIBxvWveTi3dp0erR5boH/5zvPmx//4ZxIuian5NcC1Q/fdz/DPRguOjhlfPz4Fb13PC4tZVNT8Hbl0v4Bzbo6ho9HOZ3Z3EdmzJpVFl2WIRIiZkFfiVO+juI+c6Gjih0oJ52FaruzeIOzR1hfz+PZL4geqJz7ITvQpzN3+n5MflXXNJhHZCOQvaCeUsaCeUs6CdUM4ieR4KwlkkzyZFOAvaCeUsaCeUs0ieTYpwFrQTylnQTihnQTuhnEXyPBSEs0iedYZwFrQTylkk32lCOIvETghnQTuhnAXthHIWtBPKWdBOKGdBO6GcBe2Echa0E8pZJN9pQjgL2gnlLJLnoSCcBe2Echa0E8pZ0E4oZ0E7oZwF7YRyFrQTylnQTihnQTuhnAXthHIWtBPKWTDDUHlXA8byLp25vE/L4ofE28sdq1td5QVt/U4eVPEIF16/vPLE/Qc00FnSymt1NDymy6zLv3O/H50zPExXt+uBnuo16aP6bppJe69DZ1GckyCcOTndy+va/IMjvugRt234uZKtzBJKwSNR7F9zn0FnseuueHS1z+7p6/dvlFPrmOLfBLT1fFT/UmfkdP198TbeSyTPgM+X8Ey6LfbTrmezN6XPpcGQiPa9/CmcOz4ThMe12NYO/hkzP/bfP4N4UdTMrwmuG2r/fo5/JlpwfNTw2vk5cOt6SVjcumrm58Ctqw6MlZGTjzibZiF5PLfOqTmQ485j3s93L316mq17c+S3S1K1BJxQecE8Qud5O06EtrG+1zzQaMYc/X254G8le0Vd6g7b9DozvjRx6CyUyaCzUCaDzkKZDDoLZTLoLJTJSJ43gzAZyTNlESaDzkKZDDoLZTKSZ8oiTAadhTIZdBbKZNBZKJORPG8GYTKS584hTAadhTIZyXe7ECYjcRbCZNBZKJNBZ6FMBp2FMhl0Fspk0Fkok0FnoUwGnYUyGcl3uxAmg85CmQw6C2Uy6CyUyaCzUCaDzkKZDDoLZTLoLJTJoLNQJoPOQpkMOgtlMugslMmgs1Amg3mHysZ6MFZ1+oJudspdhw0nsmWuhScW0eWpFS75sOWM53d5ya9KJ4qgyXjtvE9vSDw5eemc3cM4D9MVPpJSCobpcj/vZ8zmf1w66gNNxvqtcuneVodmytG2nTLrJzvFs5SvGnoJV28tOpKrs8s+meTfDU1/vp014bvM+7bzm+O6Y18/7lV9N5Jw4crNKd8L3LTn46DJ6PZ9/HVHJ21SelSNTe5XLGOvqtcZ6rk4XhYjdnO3vUyWxDG4xqifXxNcYzT8/Rz/TLTg+KjhDfNz4NbVSFjcuurn58Ct6xUYKyn5yz0g4u3r74mf69Kjvym39Bv7NjkKUajtM6+21PX6DidUWTCPdFQ8l6/HBqXqzxmd5druEkn3YzO8eoxG1H0a4kPN9xyEJkP5DZoM5TdoMpTfoMlQfoMmQ/kNmgzlN5Ln+SD8RvIsYITfoMlQfoMmQ/mN5FnACL9Bk6H8Bk2G8hs0GcpvJM/zQfiN5BmACL9Bk6H8RvIdN4TfSEyG8Bs0Gcpv0GQov0GTofwGTYbyGzQZym/QZCi/kfxONsJvJN9xQ/gNmgzlN5Ln+SD8Bk2G8hs0Gcpv0GQov0GTofwGTYbyGzQZym/QZCi/QZOh/AZNhvIbNBnKbzAbUTnaBK/JjDrnMrpPYlcfVn4c/RoqXp+TEq1Cy3NbQHQ129M5XjroN3nJY4rsQl5XL832KX8v45iwvOp1N/Jl/XRKWHzVxcGPcdBvignhlq4P2qmW0KhrqY2UKqZoXAl4MFcSEOhofH0li2UcyfMYC95fOmu3wbFJNk5u593KvFz3kz6tQyyW1ad0L25rkZ4k+bfL/nhq5eiMnvbm6bvTvj/93d3MH3cyr73EMFKRu0Pg4p+PCOF6pGl+TXA90vz3c/wz0YLjo4Y3z8+BW1cLYXHrapqfA7eu12Cs5KEA+u+HD3zK71F7v9/m01Nettr3vv3Gv0VtOXaXeUdthhOqLpiHd3XYsBkhX3v40bX17LGb63UNqgyuG5o/cBNstP9SL1cJ/YayHvQbynrQbyjrQb+hrAf9hrIe9BvKetBvKOuRPC8JYT2SZzgjrAf9hrIe9BvKetBvKOtBv6GsB/2Gsh70G8p6JM9LQliP5HmMCOtBv6GsR/JdP4T1SPyGsB70G8p60G8o60G/oawH/YayHvQbynrQbyjrQb+hrAf9hrIe9BvKeiTPS0JYD/oNZT3oN5T1oN9Q1oN+Q1kP+g1lPeg3lPWg31DWg35DWQ/6DWU96DeU9WCOojL3DRhL16X1kVps7MBlu7ujhbM/6y9V2m98sTn7J5deNJuiE0UJyfOoPlB0ts5GqXvwSxSUryIk2a5bU2rn9MA7OeXm1/B+mTmS3+2Sd+M7xOB2M77jlHBKTV6qsyr/noSO9kyv917lP1c8zYTWY3t3zX7uUarx2N2ewwNty+XftHYwSHjdlCu88JH9Ol/ASpLf7XLo3dkbw/dBSED/29lBe6p1h0sDmm25gm3pleQOlPET4wLbLm/m1wTXLq1/P8c/Ey04Pmp46/wcuHW9JSxuXW/m58Ctqw2MlXARv0C5e+yFWKbDTZ6J+y1BK4zaxFdezV7JwdO6XMH4GZxQbcE8NHd7u5XEf4TuSJsI6f1RYDBVfHfCtPEBnXSxaMF75mdi0HooF0LroVwIrYdyIbQeyoXQeigXQuuhXAith3IhtB7KhSTPo0K4kOTZ2wgXQuuhXAith3IhybO3ES6E1kO5EFoP5UJoPZQLSZ5HhXAhybMxES6E1kO5EFoP5UIS6yFcCK2HciG0HsqF0HooF0LroVwIrYdyIbQeyoXQeigXknznEeFCaD2UC0meR4VwIbQeyoXQeigXQuuhXAith3IhtB7KhdB6KBdC66FcCK2HciG0HsqF0HooF8LMReXzOzCWT097+/DxFI2UG6WZIpuHAxXvCp85K3j1cRXTReYPt5ZSQheyXyhj+iBXpfVic8eX+8zWia/K+kO/MdxwFoyfG+k4IFQEXci48esQ42/1DQpGnG/pp5ebmNvM9SvVx2xZa9rcebcrwwO6kKq2ySnh4ItpxsT4d+FUQWWXy09elrz9wHCV1yFLkSNLpkg+V2c4sWs4/krmqzl9axvFyrHXzOdYwwWMHuXd7Lt/JIH9w58x82P//TOIF8W7+TXBdU7738/xz0QLjo8a3j4/B25dHYTFrevd/By4dXWCsawsjqzUB2US9NOdFY7FHezjEXvSuqNPn1OtV7PGYNv6N3BC9QXzUJ08eYOq/V2KNlOk0pvpX8c421RG9QJ9KJet4Hp/tmvNa+hClCGhC1GGhC5EGRK6EGVI6EKUIaELUYaELkQZEroQZUjoQpQhSZ73hTAkyTPTEYaELkQZEroQZUiSZ6YjDAldiDIkdCHKkNCFKEOSPO8LYUiS55QiDAldiDIkyXc/EYYkcSHCkNCFKENCF6IMCV2IMiR0IcqQ0IUoQ0IXogwJXYgyJMl3PxGGhC5EGZLkeV8IQ0IXogwJXYgyJHQhypDQhShDQheiDAldiDIkdCHKkNCFKENCF6IMCV2IMiTMZ1SWd8HjRqr1VC+/OjsunqGRYfXRud5n8HXoS/qfwsN7b0XbrFeGhpTsmVSI2Cwk1h0kvqlWdpXS7XP3NHyXDhz7cvLl9uoVK9KgISUkYzXr065e+R3IUivvofPAZu/bT+Kfx3rcaKq1WWiHfaEh6Tv7bJS1thsL2ziUal55ZXROoPlrz3ua5OzNx/vnWH5+g4ZkkF+9Jd83qUqZtWDsjJeWHuEZl5vP6YOr03+cT68o+UpcXmwTdc2vCa6Juv9+jn8mWnB81PDu+Tlw6+ohLG5dXfNz4NbVC8ZKs1HFi8vmyLouK7TfUHm+6sHA+fSMX5ctLrxWSb01V3QPTqixYB721srL7e9vvDlb7P+TP73tCG2Y+YulIUEPQx4K39x0YakwNCTKm9CQKG9CQ6K8CQ2J8iY0JMqb0JAob0JDorwJDYnyJjQkypvQkChvkjxPDeFNaEiUN6EhUd6EhkR5k+RZ9whvQkOivAkNifImNCTKmyTPU0N4ExoS5U1oSJQ3Sb4Di/AmiSER3oSGRHkTGhLlTWhIlDehIVHehIZEeRMaEuVNaEiUN0m+A4vwJjQkypskz1NDeBMaEuVNaEiUN6EhUd6EhkR5ExoS5U1oSJQ3oSFR3oSGRHkTGhLlTWhIlDdhlqNy/z0YS+PKfaXwYGrnk1deovdljxxx9fH2sPYyTczZp1vT96qNFXqT64mxLvev6V0r3x1p3DQRayD5KcPJm+rKWfdNN+p5LxgMQW/yzRzPo+qymuo/31l18L7tp185m2ZMhL2XXjvXJ7HaQnkKelOlWUvv5KaEsNayVWmb5L4HVVyc40nkO+E2YbuPrT18dQ3J70grjb/a+YvmqK4lXZH7FndFW21JpbgbcQNhBuNGbtlFQsQxuH56P78muH7q+/s5/plowfFRw/vm58Ct6wNhcet6Pz8Hbl0fwVj55y8bfIzuVDQ0jfQMr+dlDDm4fjaXfq5v6aBacu/I+hNwwiUL5mG9XCS1hertZ8YDO3wLH5SdkmemURG6+mKNJL/IV9rlYduhN1E2hd5E2RR6E2VT6E2UTaE3UTaF3kTZFHoTZVPoTZRNoTdRNoXeRNkUehNlU+hNlE1JfqMAYVPoTZRNoTdRNiX5jQKETaE3UTaF3kTZFHoTZVPoTZRNSZ7fi7Ap9CbKpiTfBUbYlMSbCJtCb6JsCr2Jsin0Jsqm0Jsom0JvomwKvYmyKfQmyqYk3wVG2BR6E2VTkufVIWwKvYmyKfQmyqbQmyibQm+ibAq9ibIp9CbKptCbKJtCb6JsCr2Jsin0JsqmMPdRRvgErx3R8ZkNXTvyp734w/uNTuSae/Cuy9BoYT7NNX6hMal0M8nvZ0VRMcRefrnZlH2J0SNxayfl0ijD2IpaHkfV9o0ssfc2Q5vSUDgFJHid/mkQHznM62s888Nd55ZNgsj2TaJt7Ly2N/1JvlNj+ON69lbz0yESZ7xf7d29PXn11sh1Cu4am4JaA7WY96+CNuVft0v/ffPs522NrQZiqyn1zlmF/IhguP1hbkSUveTlF+LH/7Ct9Wl+TXCt1f/3c/wz0YLjo4b3z8+BW9cAYXHr+jQ/B25dg2Asi59/bu7hjdKnTEy/rrpn9TL6tJKCVNOl7CmvR/fPbvh9AE64dME8bC1UmTOq+9Z3hL+tL4jYbpUUturAUaa9x2eyvV2fElyOQpuiHAttinIstCnKsdCmKMdCm6IcC22Kciy0Kcqx0KYox0KbohwLbYpyLLQpyrHQpijHkjwPEOFYkt+WQDgW2hTlWGhTlGNJflsC4VhoU5RjoU1RjoU2RTmW5HmACMeSPEsZ4VhoU5RjSb4TjXAsiU0RjoU2RTkW2hTlWGhTlGOhTVGOhTZFORbaFOVYaFOUY0m+E41wLLQpyrEkzwNEOBbaFOVYaFOUY6FNUY6FNkU5FtoU5VhoU5RjoU1RjoU2RTkW2hTlWGhTlGOhEVCe+Ayv9bX+I1X832W7raXYLexct+9+HZRlJf9yv+6rAZ2fuhI60LFKG9/YdO2IzbrZ4xhuF+biEqwl1Hiy1lx9tiHHVY559VmS5y1e8W06KxgwuE5X8JKfxSFz5h9Lby11iB6k1aoSpF/y5hF0rLgpbU6FT9vLDxnHQt4ZJOZMPphbrvOqk34FR1Zyhua3n9CxQuGlwV+yH9rotv+8HX5ub/Kjpt5TDyg5V4VcqDU0Yq6j+jP3v8cl/NWL4vP8muC6bOjv5/hnogXHRw0fmp8Dt65hwuLW9Xl+Dty6voCxSh+WTPooW165p+x91ma/yNu6h+KMFbnyDrU/Vh6PdfFSgxNqLphHfOevodZ3Ri9f2NYOD9+gPEoT75+S5aUauuz9ULnbqS3hJM9bRJgXOhZlXuhYlHmhY1HmhY5FmRc6FmVe6FiUeaFjUeaFjkWZFzoWZV7oWJR5oWNR5oWORZmX5HmLCPOS/CYIwrzQsSjzQseizEvymyAI80LHoswLHYsyL3Qsyrwkz1tEmJfkudYI80LHosxL8t1whHlJHIswL3QsyrzQsSjzQseizAsdizIvdCzKvNCxKPNCx6LMS/LdcIR5oWNR5oWORZkXOhZlXuhYlHmhY1HmhY5FmRc6FmVe6FiUeaFjUeaFjkWZFzoWZV7oWJR5oSdQ9hgBY5k4Z66eX+Lw9XFSb+Cc28vozcscx4eW3Ex0fv2Ogffp7BVoXkVNdo4xP6kdg4qP2JZzib8eyXlYHGWkYe160qVjeej4XmheHlkdtYmstozYHVucmx4EZ5gwrj0UpsY4liIx2rCUZVoWmle4vmpnqPoKj9I7b/XkJUfP3455pbQk6EJ10WcqzmH6BybQvMKBPqc8Tq5nMS470eP+efIqWw1r9ylt7yZvEyeNy02f/3zkEddwI/Nrgmu40b+f45+JFhwfNXx0fg7cur4SFreukfk5cOv6BsZyfV72/Y3B9Xe9IZncnXSPlrZs22u6kzXp48ctzTvdWihc4IRaC+YR2/38CuuIAF2MZH6vxcVXIXSXvlR5/Dic971hbZn9ksct0LwoH5M8zxLhY2helI+heVE+huZF+RiaF+VjaF6Uj6F5UT6G5kX5GJoX5WNoXpSPoXlRPobmRfkYmhflY5LnWSJ8TPJbLggfQ/OifAzNi/IxyW+5IHwMzYvyMTQvysfQvCgfkzzPEuFjkmeMI3wMzYvyMcl35BE+JjEvwsfQvCgfQ/OifAzNi/IxNC/Kx9C8KB9D86J8DM2L8jHJd+QRPobmRfmY5HmWCB9D86J8DM2L8jE0L8rH0LwoH0PzonwMzYvyMTQvysfQvCgfQ/OifAzNi/IxtAfKKd/BWB6dLMroazwhYhQWlbdzT6m9n8t6fdpV5ir7F+Ouu/7HK6GPCQ/aBBxeD8Txix2rWfH5epTC/ZSdnzoGfp/Pn77KoqaxBvqY6eYqq6hCzkSdB3q5DmLvbM90an3clUhYJfP+4xPh6w+OQh9LhYePig0Kb3jYzP0lV85DsHnDzsYbN4Nu8vDPhPs7jPiR/E60fZvx04p3c/Gzs7PnP1WE5+xk6ip6Lno6SWrG5OSZwJPEMbje+z6/JrjeG/v7Of6ZaMHxUcPH5ufArWucsLh1fZ+fA7euH2CsQl9WZm+M/mCd8PjD1Uu2laTub1C6Nqf3ZXUI9e4Y3xcScELtBfOw2zTqJHEmufROXqrg9NtXwjbXtDLAv3f/L8MCJ08vFWfoY5SloY9RliZ5XijC0tDHKEtDH6MsDX2MsjT0McrS0McoS0MfoywNfYyyNPQxytLQxyhLQx+jLA19jLI09DHK0iTPC0VYmuQ3eBCWhj5GWRr6GGVp6GOUpaGPUZaGPkZZGvoYZWmS54UiLE3yvHeEpaGPUZYmeVYAwtIkPkZYGvoYZWnoY5SloY9RloY+Rlka+hhlaehjlKWhj1GWhj5GWRr6GGVpkueFIiwNfYyyNPQxytLQxyhLQx+jLA19jLI09DHK0tDHKEtDH6MsDX2MsjT0McrS0Cko0/wEYwl5XbfoGMu3Nvnnl205/sbDoMNqlnvv7z6KgLIXBt/NKUiex3qYbfybC43s5xif4q/cCiqqHoaq0s2HaK89N7yxe9WHGWhphfWnFZSOBVAdKluvmzkUny6eqXnh8jfufVR1rBMKp7fVQ0szXH6w48qxR6yevbl6thFyv728xb9OR+W9v8N7/tLvsBsG0NLU7erX8m8/kyxKWPHj14MdzZRHX4783HPnPHOM0snTnH9+jg7bhj/n1wTXhhN/P8c/Ey04Pmr4xPwcuHVNEha3rp/zc+DW9QuMpW8/7bzB5azQzquRFuHRt39Z3m4QzdMt2mA+9kRwuQ1HDJxQZ8E8EnYBFyL0FYMbGf2tAwIF3nEcS0x3KHpHI/Pji+6G4UfaJN9hQ7gbWhrlbmhplLuhpVHuhpZGuRtaGuVuaGmUu6GlUe6Glka5G1oa5W5oaZS7oaVR7oaWRrkbWhrlbmhplLuhpVHuJnkeK8LdJL+dhHA3tDTK3dDSKHeT/HYSwt3Q0ih3Q0uj3A0tjXI3yfNYEe4mefY+wt3Q0ih3Q0uj3E1iaYS7oaVR7oaWRrkbWhrlbmhplLuhpVHuhpZGuRtaGuVukmcmINwNLY1yN8nzWBHuJvldQYS7oaVR7oaWRrkbWhrlbmhplLuhpVHuhpZGuRtaGuVuaGmUu6GlUe6GpkH5Zwq+b/muMXSOzfHGCWzLbXpquWdyWuOsNEyP0NMxLa3QlEyC7lbRMCl4NnhRKMDRoTHqS0Td3q6woMd0qixRDh8tzkWYNkJ3S6ZktrJ80OVOr9cwz5xrU1S7l1cgaLsntL5A/6K8m+oQdLegvWr92Uq3B8djA/YSnGYYpaXqkrRbBFdlVaxP1qR7YQbdLbNvWbGE+tNNzStN4y4vlfdx6qWk3y/A4bx+eOfy/uWdp4hjcB05Nb8muI6c/vs5/plowfFRw6fn58Cta4awuHVNzc+BW9dvMJZtI7vxfc9UGoHDt0tNODcs8fosKD99ZCRt7TCn6VON3WFwQt0F83BzMb0vNvz4YKn+stfDBQE/VsifHFWLVj1i0xBbQeOXPwPdjTI6yffzEEaH7kYZHbobZXSS590ijA7djTI6dDfK6NDdKKNDd6OMDt2NMjp0N8ro0N0oo0N3o4wO3Y0yOnQ3yujQ3SijQ3ejjE7yvFuE0Ul+8wphdOhulNGhu1FGJ/nNK4TRobtRRofuRhkduhtldJLn3SKMTvI7CAijQ3ejjE7y7AiE0UncjTA6dDfK6NDdKKNDd6OMDt2NMjp0N8ro0N0oo0N3o4xO8uwIhNGhu1FGJ3neLcLoJL8diTA6yW8PIYwO3Y0yOnQ3yujQ3SijQ3ejjA7djTI6dDfK6NDdKKNDd6OMDv2DstIsGEuxz8HXi8cpMjf9WMqa56p8eboJ9hoKDJtnH7/hprTfYAuNLpvHOnSC7s5ttbITP12yvLbs9zTyPXZdOXTlyKxrwuPZ49Do9E1JXSaH1FsfZ1W2ixdvOEXdeus0zY7GYI3M5KDYMlF3aHQKt43VqVqOrlrKklbLwlx9575qPr/APMzVc2+9LH/0qkASo/sx8XbNND+zO53n0ST71WBn/7JjN1jtZLkymH9dPcK168/x5sf++2cQL4rZ+TXBNefc38/xz0QLjo8aPjc/B25dxD8gTvj7FznrRfxDuHVRgLpo7jdaHXblf+4is4swcKRig9952fJNj4QlZtdxPq0snROBEy5bMI9K05fSjNsu8uetUs08fz7mcdTPqp1+6LyJ8cnrSYMENXtodJTnodFRnif57iHC89DoKM9Do6M8T/I8YYTnodFRnodGR3keGh3leWh0lOeh0VGeh0ZHeR4aHeV5aHSU56HRUZ6HRkd5Hhod5XlodJTnSZ4njPA8NDrK89DoKM9Do6M8T/JbZQjPQ6OjPA+NjvI8NDrK8yTPE0Z4Hhod5XlodJTnSZ6hgfA8idERnodGR3keGh3leWh0lOeh0VGeh0ZHeR4aHeV5aHSU50meoYHwPDQ6yvMkzxNGeB4aHeV5aHSU56HRUZ6HRkd5Hhod5XlodJTnodFRnodGR3keGh3leWh0lOehlVCuogRjuQs+rXHqZqSsK5DLGacWt3t40zby8GfVMDFLShlrs11yJH/nHkvzs/fY0xDrwUEzO8osx1wngdhwdXHXkDX0IjYH9odCzwubEDiOvzmZlhw/1fU423EFDUMW7++Thv6f9GlXnA1StISeZ9zDUcTFfODYmtfcLIpDw8v3lWdPHr5Ly1r+pXL3N5fZNJLfHlZxe/DUyf+8iXWhV+FXNgEun8Bq24jlQSzyG/eovtpH1m8PE9eDkgyfUi2ym4nHpyKjLupFrou4VtRk1EUD6pJfS0XdeejTgSc/LZ+lBT2PX8neciz1yEOWb49f+Vp9H5uDE+otmId5/aV3Vq3mSU08qm5mOw50qGxujhFVrM+6ctNdXTHETRJ6HmV/6HmU/aHnUfaHnkfZH3oeZX/oeZT9SZ7XjLA/9DzK/tDzKPtDz6PsDz2Psj/0PMr+0PMo+0PPo+wPPY+yP/Q8yv7Q8yj7Q8+j7A89j7I/9DzK/iS/MYewP/Q8yv7Q8yj7k/zGHML+0PMo+0PPo+wPPY+yP/Q8yv4kvw+CsD/0PMr+JM8SQdifxPMI+0PPo+wPPY+yP/Q8yv7Q8yj7Q8+j7A89j7I/9DzK/iTPEkHYH3oeZX+S5zUj7A89j7I/9DzK/tDzKPtDz6PsDz2Psj/0PMr+0PMo+0PPo+wPPY+yP/Q8yv40GPanBWMVBETT8u69/0LxRrlk1bGrJjq/f/JlsN3U6anuaDyruS8G2p9vg+OdoeOtVP2W46rGoxodK5IvZlo3HGfxDQu7qEMTJwbtT03N7ECvzRd0eWekmvDL+v7veZ6F169uTFHcFs9YdfLTGLQ/5+41RmaTTR0Dq54kFn+6byvsve8BVU31qZ28T+9Qnt0RCe0vTrPsBHWEdR/F2EqvrthHPjnllh5UoxH5FpknxC0CtYmPuMO2LHE9aMmwLN0iG5t4fDoy6qJf5LqIa0VPRl0M8HreO/hQkGKv3bk9c8ERbpS/7Cj7Zagjr9SczGKuTjWkLYQT6i+Yh2JF/NklPxT3rIswP6D0eNUUs7edZ8j6jAi1etXJF64UT6H9UfsEaH/UPgHaH7VPgPZH7RNIvjOK2CdA+6P2CdD+qH0CyfOwEfsEaH/UPgHaH7VPgPZH7ROg/VH7BGh/1D4B2h+1T4D2R+0ToP1R+wRof9Q+AdoftU+A9kftE6D9UfsEkudhI/YJJL8NiNgnQPuj9gnQ/qh9AslvAyL2CdD+qH0CtD9qnwDtj9onkDwPG7FPIPmtFsQ+AdoftU8geaYKYp9AYn/EPgHaH7VPgPZH7ROg/VH7BGh/1D4B2h+1T4D2R+0ToP1R+wSSZ6og9gnQ/qh9AsnzsBH7BGh/1D4B2h+1T4D2R+0ToP1R+wRof9Q+geTZFoh9ArQ/ap8A7Y/aJ0D7o/YJNBj7BAaMfQIjGMs63cUjyP3op4zb+JH+sEcvBlWKflQ4qn+d0b7w8pkd30WS33RUqXhnVUjVqZQmMzzmfYz2+of9rC/dIx1Yrtz18fvkkAP3CVzSktZq5UKP7CLefv/MXZ597cOxvun3h8U97WhirTNkQuE+gUdxrViI8Q9tgf297BuGlm69S3uNi/1S3bmbdaqh9G09uXCfILuzILdxSY3LOnNzsX6b423Td5X8Ho/QLRH23XLGIVohhTiGYn7sv38G8aIgrgcjGe5lWmSPE4/PREZdzItcF3GtmMmoiwXURVnezrnv1Drq3Z1LIlLsd6m9bf3Gk9NjVEvT6avX5PDWBE64fME8DB/PtQW0mb+P5dezMfG/57ydllFA0Lbn0PW8cF+q7u2VcJ+A2lPAfQJqTwH3Cag9BdwnoPYUcJ+A2lOQfB8WsaeA+wTUngLuE1B7CpLnjSP2FHCfgNpTwH0Cak8B9wmoPQXcJ6D2FHCfgNpTwH0Cak8B9wmoPQXcJ6D2FHCfgNpTwH0Cak8B9wmoPQXcJ6D2FCTPG0fsKUh+0xGxp4D7BNSeAu4TUHsKkt90ROwp4D4BtaeA+wTUngLuE1B7CpLnjSP2FCS/m4PYU8B9AmpPQfJsGcSegmSfgNhTwH0Cak8B9wmoPQXcJ6D2FHCfgNpTwH0Cak8B9wmoPQXcJ6D2FCTPlkHsKeA+AbWngPsE1J4C7hNQewq4T0DtKeA+AbWngPsE1J4C7hNQewq4T0DtKeA+AbWngPsE1J6CBmNPwYCxp2DB2FOwgrHyNdbnV/5KcONlynso+zst7/LSugKbZ62+nfWFF99+bvxK8rkj1hhzT79rNyb4U0Y/ly59V95tsu05C4+48m7/K8IOc19JfouT5oDl+N7oTYIH8zvSVLON9osqOUhUxQ1FDN/ooze/uBHuKeS3qzaPvZ48tW166e0LT9ulT/uvZXlJYXkn1/RJ2p4Xv0k+d0Sn7cDoQNe0WYEm7vuvk5/Sug+tyu9V3PKRsKLobpQVef/2QFwPVjKMzLbIdicen42MutgXuS7iWrGTURcHqEt1ucnPo6Zi0Q5jjcF6latopCVfF0QN/r77mDs4a+Osngec0GDBPOJJSicMvGgCIzuTcl4wnzcsycz7XJsRpFuz9vS9HS3LNeCeArX/gHsK1P4D7ilQ+w+4p0DtP+CeArX/gHsK1P6D5Lu+iP0H3FOg9h9wT4Haf5A8zx2x/4B7CtT+A+4pUPsPuKdA7T/gngK1/4B7CtT+A+4pUPsPuKdA7T/gngK1/4B7CtT+A+4pUPsPuKdA7T/gngK1/yB5njti/0HyW5yI/QfcU6D2H3BPgdp/kPwWJ2L/AfcUqP0H3FOg9h9wT4Haf5A8zx2x/yD5DSPE/gPuKVD7D5Jn7CD2HyR7CsT+A+4pUPsPuKdA7T/gngK1/4B7CtT+A+4pUPsPuKdA7T/gngK1/yB5xg5i/wH3FKj9B8nz3BH7D7inQO0/4J4Ctf+AewrU/gPuKVD7D7inQO0/4J4Ctf+AewrU/oMGY//BgLH/YMHYf3Bg7D84wVjKButdaR58bHHOa91nHYbo3XK3xn9ZURTx9NVG3kM7Avvg/kOo1kbXTH365cP3e5V960U8WR6fK20wXhPAe+gl/ewptnCS/YfNl8aQI+Uzqw7M7LUWk5c8de7HD5eCPDvxgru0Fo/FE+D+g81G8oXt7JhyJd8LP5NUVdpayhHGtzPvx474tGc4VG04C/cfgjvMKBQvnk86M26/Y3J/SUzckv3Wn1q2TJ1ZS+PW7LnGnTiGYn7sv38G8aIgrgcnGZ7mWmTnE4/PRUZd3Jh1/fv6fzlfNt2Xau/hkfETmp0sO5riQ2gO86nG6v8YPHxQP0dF9QZ0vtzrjtU/vTUco1+bN+f+FiJIr+FoqT2+ovPy6bM3piinL0DnM3DbLz2h+8DwaP4ZyedsdfXr+EzGTzcJMGtUvNxmfI1tB3Q+y8mVVBVGp/fN7dort60zuGw3v76aaOi7xyYOJ8MNa+64QedzKBwR+3nyWveEbaPUZ49nU8U6iif8gu9KFFYW1Y3xez+FzhdM1/lyUIKy9pzStRRvw4cCx5Wfly45GlG8eU3r7v0yYhHQ+XyRy2oPX+US/abGkBwerZXnIlWp7dOQ5ux7/dTyUEZqNuh8wU1MziuaorPiBgTrDaYnGth3PzzJbxMlM1FHENHlPqS+iWQdDvtR7dCJObdqv0lzq9yjqLszTjKKe0Ur6Wi0tVaH34LO57Jdt8m5Qa3aL3Q9hyjNVBBnf8NsFUvzbRpLjatvAmo4ofMZC6izJFdKH1Jpsz9w53yBiLLmJ+OfMY+0hdpEeGVe6HRA5yvaH2hUl77oPUHrkbm/TTHi/Cm5io1Lfv2W5lvFShMksxY6XyqMS3ubS3jd/jNzCWu/Oz3kckwSObXkUIBLf/fwcaGWM9D5rHYrblB4xbiuS40V3Tzj+3kgZvqYXkI6/T2O7Ktj/Vms0PlcxsuibX/GDPbl3rRM1z2XcveB0EnehFme44l8ihuXVm+DzpfrDOz19vd7r0qpLPlJPPPxJcppHs29ko8nmLL3BT3m+kLyLM0LAtJ5Ia9lz0pnSgWrRQ/tuSl84PopuS65Z/6V0aM8CSS/26Rh53d46o1/lMB1CUf3Q8y+Icbnatavl9kyGn91Le2LFdD54vfjk5Zo3SlSfzhq20rf6GW0iW2Tj+qXPO/7a1I3tHeNkDif+km/5jSVZNf1yzTh05qsWuWc9zLttx/q9Xdf+VZC5zV0vurvx+uWuz4YYrOd/T1aenOl7x11ycvNaRzsIuZ+y51ufoDO5824pzscVjXweDyQoe6I9/LcRJ0COfmfrm5iLDunl9xjhM4XiX/DcOfKmpSA4axb52vtmR7bVJvHiu/b6LzsxXL2HG+S7xfwvuhPvtjNLeAtHr27TZ0mYOnj9KKbesMxlHNO6yQfMjRC50uXH3AbjP3uu3fTt2LGJRylt73q8r0/v9LPuJ+fW6ylmQydz8P07lGM012V2HV9vt3Ky19rCD5lmt0slsPg3HvzvQO7Ncn3C+y/nq4LFBbeRKt652gu5RWBq+OH27rZiiTdaZItx2VjoPN5ZcebXvqpmLW+eOGmXpYr/qb8teXSieL6lGavzUICP/yg89mkPm1Qsmu1LNZv1Bnv3jMx/c051oj1wJa15wzXzKYaZ0DnqwScr73/8RKbXrfUde1zK6N5bhdKr+N6yH8o4LQD00l3W+h8fjemTTt645Zs3aQZsPXgTIkF65a9BqWFNuvUckfTRb/xQ+dT/Ii8crCM6vvKV85nlLUUfVWeKTV9NFjxfTzFRnCS3YHkt0pljtd9uys0OjjtEzhwZuCl1FtZwtiWa5/V/NOFhoVaKQqg86U3vV5feSGP/vug47UC19er/F1HGToyUuxj5fmi3O+6FkLn836j+l3odjH7ycCjC2YnaYpCvaNuBAQpSAxu2Bm97daNW9D5ypUJWfWXrxXIpTFcejG+uYlGUzH3qheVX8LE10uGdPVHofOV5CoFr+j3NF/9oq3OED5BEeLEK1Z2Z73M+IkD35I2iA9B51MIRPk8et1GmaBAuWzoymwwbYJK3pMvdfduU15iOmm6Uh46X7ZaeNpads/PT/6dGmy9nG763pP1osuX8RvsMD9Xr25yFDqfP47eZbooPpE+6JvYr1qJ5YxaOuw8y9Pb9lBV/zpGdUIQOp9vwH6d6wC9tbF0kWPsTnvHFY9uRz8QlH1762q7k/2t7gbofKFQ2iOxBVETVLR1A75Jp9JWTB0+cCFeXyhxS/aLsVX6HtD59Cec79i3FxxqOToQXv6yduzj46fsOrkj1kvSH9AxBtxmIPmMETfLrqDvYwo2yspxx7W8XDyj36js3TMqJ785KK0k/iE/dD6zgQ9V4Csdj3NnV4SuoS08Jr2L+lo/u2mmYt09Lb3VwyT/dsD7zSxWa5RuTVaGgOSVzj2ZK7gzJL+9v0IlKfksQ+B9+lOS59Kni2j9nByP/bQ+4+uSOwGbHjHvUZQ3iVeSoEvT8To7lQmdLzbIE5F3RfWGxcEbBw7R+qgH/3bzoVBg9OJoGbsWceEcH8kzfazf7pG4cPLtqXcaNA+knmQpRw4EEg4ZrJwyvOw4INfwBjqf94JNvoy7WB9PvHtP2zrWEi0+0eWTlzidyh9tTV518FMZdD5r5ZNhu3HD7VutE2upjVo5+Os1ihyqt99wcsxL7rGycIbOF3LjJ2Sr2uynSai02p6b2vDg4pfvX3RkNBwK7/E7XRrzgM6Xy1Vh1Dz51Zzi1Jv3yV6DdqV5eY/LM4zs2x5uP6Ena5oDnS95dW96Z1zse5lNeqdZX+UuZ6Lsikn2cNTa6cTYef2Ndg50vuqA4EDBE9b8FmNfhnsGLU41F2uPhDOH2BbUJm/hNHjgBJ2vePz20a36Z04/kimWuRqbJj8bVz0t5nbF8KvFkxjWs4LMOM7nAWM5Ppl/W2LSOJYTsUmB61HQuxqfKtq16nx3KLK3tdFUzjRA59O7nqLNdf1k1RUhqf7EgOZL0emdOdn732xSTvJZwRyaPgCdL3dqZNT62+3e/UaTzZsomtYndLVd8qMO2HaaY5PWdRqVJJJn+R+b8ram3S+Zn5L6U9eH83rh3pQPPunSa7nL4hX98hkPQOezjPkcc7gsM6ChFMTeFH9my4vZB/nZkkeEIqObmkzDjqQRx1DMj/33zyBeFMT14CHD07yL7Hzi8XnJqIsPs65/XwudLyVDl9hy4fbeZ715P0qWcRhbrV7aVj/JYrSx23vZ8ggeEeh8WcrO1s968vQOSwTdUs/s35PsMzS1jW2HnNvY7QOPz79fCZ3PyJy0522GxCWp7a7S42Veq0P3S6d/8d2oZ7eXOybpV+he6HzldOfptZ9u3NZqy/FVUT+7xXdqn9R9RzWxbGPLHPZqPjnofCEG09J1lRWh1lp71qz/sWXu3IdlSayOl1+3r3RX/CyknQadL/SpaU/ymSyGrXW7945KihnEsVR8rK1Oo86Z/H5rbsBlEDqf7tfoZN2eCJ8dDkeNnjIxrHx1/NvJYiXVL/5r9+1NV3hcT/JdgsrhoSSBhzbbot9Hv91w9Klg5EX7l8mt189E2HUtNXnRAJ2vuvLukOpsF6ON81sL0XXBJXV7H46o6ep7vFEc42i43LUNOl/06RYBpqLUnsFOwV+XP49lcGWyHp1y3sspuS70UMzg+18kf5//9tQ5KccL9ZGCP6/V3T1KVWoebKwQbU4wo/Loev3YyQ06n1r7rStXVMBcHnvQVlaZSAUa/uEvVurn1q4JqxvqORg6DZ2v1iGYLdPNfzK8q16Vm2NdvhjFl1C3oJEmOY2uV9cCrrqQ/P7UYP5ev82ttGwTzuK7bvIKrst5Gt/Afa+oVsdD37WKmeSZ+ZTP+7mHY/tCuHsbha5tDF7OconmcUX+nOuTO8ypDSX649D58nnM+nUtB/QpvnG8KzgwsmNqTahR1+8SpRJdh3Uf3q9wg84XFv/O5CB27s3BJ5f4Nzd/v3Ku6/qW6LMF3WfVCkKvUSythM5nko05ED3TrrXhWdUzViEFroSK0rurGWpn1O5Hjk4F6hJInguUzy9a+uu2+Y6zdZcrTCZYBaSr7+0yT1zhM/mo/c7j/PvQ+ZztmmPGqwR27lu1TSH8Y0x92HEPWe91z5Yd/7LNNO5ymSJ0vvTb3fupzn3VY7nfKv59x8/+NJ2raXa+bwx0aTZr7N9elEzyPeImwfBvhqzflD7elil5ujNa9dsHl406q8em3woEMLR8jib5+/x02StHW3Jcs/XumEasoYxwuLDkeIT414C6e7mvdY9LMEDnc4Xmh90slVY1UqBt3f5BoCGyr708mUfl1wl3/h7qvXJR0Pl0GpkvJNPN73+tj9+7U7aQQu/0moHXKhvzd7FRGsUHmupD58ss05ZLjnJnW/d9G+25JS2ry2zFZMSu+5wObri5TLGGRQM6X3qUlyezN4zt17WSm2JVCV/GLua5SNqMF1Yf7KCuj+xRgM6XYF6ba3BUyYhlbcbayc4P2t6uz8NmHsu45bzX6iy/JsEDnS/cTBFy8bDX2TOjAdmJtXEvtbVVBC6tLKf+EPHSao1S9kOSZ3fGJ9Ee3NPToMD8eFnJnhdJNybiWG9nzlIdcNiTdqGgOQ46X1if0XFVI+X9V70hEvcPi4YRJHzaP3vMcRl1JPkeXHJEFjpfMMbeMdTDRPyBqIFVNKfrpZ72U3fl9fj2Bw10bq+nZftF8l2CwDfltGYpPefu/WZs8qAU/D4t3cczTujIaToYm7ZNKwM6n+9ZS+0EV/OK/LJfPJ1KrKZxQ882Mecy2K1pN/219iTrdeh8uWR36Tn/KDn5pVtYAiYsXunGWRhee9682lDwWgSV55Lt0PmCRzyKxx8m52x1fVDixchd2HYxzPVzzge76ER5LtvQQWnofEX3JyNtI4rHdiswB0W8n3OKDki8++xawObOn9/ov7Gv4ILOJ5xySgoXD2J7PnzBfbt7z8nvt8Kt+p9E0G+4yjDoR8f8HTpfYd3DsmW3kxNXPWFYf976u0jEgPK4z2Nfg53bn3qKHg5Ihc4XajmW5j90+lDkmRt0iSFZ71r01ANn94c9vyisV+akqvoCOp9KuKt4qu57dodb+OSpESqesSMx6oEH+qgHmvav05SV7ITOl5libuy6bTO3odX4YYdnD8O2TTPq1bGWrGcaH0ukthZ8I/n7/OdtPwx/Xfry5vfrZ11j+5J2cD7ondupLTvh4KW/o+eTNHQ+gyWXUdnVd9TtdM+zKp5w7y6XH5R9MSL74/3efZ3n1nI7kzh/N3NWjGDqmo+TflkbXmsLBJvXPfesrnr/Q6P19av0PfbQ+bSnjGkbOVJ/qMksK1S7KPbJfjCDnt82fU/czWJ/85f03tD5PJQymS921a5iu5+df0zzxPBEBfeKd6ypMqfHv6Vca9h7HDpfNeaurnIE3bTSwWrjYDrWd7Jx7JZHLq3xKAyQW89j4lwKnc9tMkJlWvBEcXDXhY12tUuKzATX+RjdVj2XF3YgIilfYCl0PgOt45ste5R0bB5lWAWaKq35PDygYZ545JG3RJNxzujTFSTOn9p/10X3oabTrO5bx0i6tumCsfDUCRauu6dcJkRFj36CzucINm+1m2tTe/Tk8cGG7sonX951umY53dA4VdTg7Lipyo/E+TrHL1VozeRaXNzcxF4mVC+i/K3Ax7co0H7tKx/hydcbSb5HzLHb4Om5bVvvd/jXbNx9y3CDV1moZlU546ZiipbRiD1N0PlUTrVrHfQkfV0oC234DPuXiUa1O3gXq2wdVb28L++3nAR0vrib080TIQGjdopWNTdGA1gsTjaN1Kb6mow55nyUqPxiguN8fjCWWzD0a5e0QLgOS76fTFkV94OImobsnr6LYoUPKp7qhIZD54vYeK4oz6Y7yEAjqTJNy1+Yde52o7Sal/xnN6Uu6UNn70HnK2lIjQYIJ99tNj1/VqlaLl3smJVW+O5LAemOInnLVGz8oPOVZ3677G21L9ynGjnoyRBgyhUXGbRG5Hna27x3MrvCR05D5/Pd9JZ3Dzy8ZA/1sgtVdNsu0nkpPvDP26FUa1kQU/vGuJI4huLfNSP81YuCuB78ZHhaYJGdTzy+ABl1CWLW9e9rofOFeAuOHBw+1yybfLcsUHt4+dZ+/oQLYv3r7M3o1gZvEwmEzlfLbGbye3DSMdbLOfKhu2MuW2LIE2PjHoYREzoqHfrz56Dz+TfJX3j5/ulwX8rP8DF9Qu1V0T2R3zMVqo/X/aw37PHygc5X5VQZEldiVT4o02slWxoXve+lzb0ZFu1VxV4VruFyLb+h85mVc22okrfRsNrUrNhUouuiXLh+R/oQn8Xk3Z7VzwYfiEDnC0yvjPCNcna1K/h2itLxOVdC+PrzOyRkqIrLqkaPGSXUQOerraxz9GC4mXFhxN717GC2/e9TZ0SZVh3zHjD88Ihj1YVL0PlMmddik/mkkg+9My3LqDvEcNAiziaDP6r3oHxE2LOOuYMkvzNLq/H0xmaPy/7+h67X7OqhlmXtT3Zt3vXogNco9WWRnSTfGeZKsnjQe5Xy/GeqbV/r4rd7GihMNkWu1PNUCetxEeU6PA2dL36tnoazhqv4Nreo+be1VZdz2Rv8u/zsTtNK7+81FV6nCJ0vlcvqJ9SYPzXQoHrL4Xx9ZGwB1YOLsVcmVoaVf3CIyIwlcf6LKUIgq+zRnCOXRp5VHLibMyP39GrE9l3l4jNfV10UXgGdL/uAL86pXXmZzrIkSxt1SW4Fmo9TKQOjncJHffOo7raVQ+czDhlL1lyVt9/56JHa+/K9W9qNPWifOaUe0uqqnrEt3O0JnU/zzNV5xZ1Xr+mcXKkqOe7ciJWRsE9+2//9vEHK8tZHXF3Q+QJ0YclUbiMTBwk/n0fy8esXxieH9+44T/dsf80tAW6vY9D5Km0C5V8qKD8eYa33CdKJ2PX5XlX33Soutitvwt3PPLklAJ0vtWpFVvKHDfI5HHTf46tSSsz5U+p5Div7+ndP2JeqRp2Ezue6f1f4FuGC0GU+8x92+sWZe5fSm1zaEKQTwF1MnTEZJgydLxYmy/AzNsGFx8YzZpD1nFh13uUKZtlouTMm5a+sUsszoPMpZHjCJN547T7jGWSxuc2rYtterttjx/f1ufxsPNZkyfITOl9FbfOhYof7Aari9oaGr0JKzv3smvCo+BXaFfxh6LLd9s/Q+YqrovibJ3gOh/RVOd6b2HNotrGZrUZ+9ITcJn2xkwpr6aDzJdxWpqUuv573TEAunX13Y1l9x977TBT5j76VMXh8cg2Jh85ntzs/cW/d79xK2xpPmc4wfssrl/vZ4/O2v701yRLifTcDOp+5951sbUyA/x6Tbce0y1eEr/Xyfnq/9TV31uOZKHn6U8okzjds0qf+fNP282V7sXYzNj3GyofUgrNnftYI3e+91asrA50vd/iEj9PznDatFBG1QJOSU0VvLn7U6VM2c42+JbhN3I8aOl+ajvb9Y6Ht+zX1jT9GqTseVjKysq0syPKysPEsz8rzPwSdr3CisknsTPtutfvn7zM93f++/qVoksbZq5yEbRHr6EsaSZ4XJOitkZCnEqvgpTPY3VFnM+s6S6UgsD18guvOm2atq3d/Qucre60bD5m4us+WUuDFm2venBYffEzlnB7WZm46kEyX0G4CnU95YnpcV3WtUuUhwfCjEXs7cyVdHt5gr3MmhOlUj6mY3YDOl/1ATeW9UmzgLougtUBqPsHzuXI5lTVLQL/tWSO3UnMH6HzVbz1fi+Yuaygpx61mr6EeH/SmFUrWthl8wh/1NLu/+gV0vsyJSh/Pdrsq8SNfpR5dOzvVc+nn3ZgHEx+3u3Kptbrrl0Pnq6QE7eh5mnYk1rDjZv2u9K/MO5a9Dt8fm7xPN1V270utEZLvAhgvLdJ6Vd//jVFtd7TeOq+eG2a7k7duNdu/vt1vmGmQAJ2vVLuka0mj2trwMBF2arsfOrWsG8S4Gz4eWynNfjJWoSSc5O/zK1ZMlam9PtA7d4qRYn9l7UWp8hMtJv1Fje417R9+7s+Gzhe/xELl/b367clDA2m1LU/bTiS1dZyRvVBw+Gz6SrbGX9eh85WiNdg+qbu5DQa94YpI3FSzU3hNwk5l66uUXK519GwbDpJ8bsfBe0v+uIz6jMBPUxFrqm0eQ1QTMiJHt54IWBV87YVeKXS+sNTpmm/SxTynbGOusvV/Vxxfv1JEZVUE5Xm6IukYjtb30PmcVZ/TXx54oO++8rHCkaQ7m6ZeCl/VOnR2gEvIUc1gl2YidD7XM5NxV2n7Ewxbfqs/b+jn3KI51HB4IqutuL1ffGdnwRmS7wK0agz6N3fqmO4Zz/1qv3PQgcn66lZPnoqRKz33mC9UPvhGcu2snoq4tDt4RvX1xvTvNFtGFUXj9NNqnfeGXO8+m7haCTqf8gXHvgG/WqHGo6YhlMHD9+7EjzmFOBd+pOfbmmD+1KcbOl/ujHOg8xqKixwjqjVFMSJtPyNebpOc6zv0SYyv6vOuXJLvDFM68Ky8+8nP23gbs+KRcLP9Py4zMDwLy/4/qxy0SiCT5yt0vtjVq91Mj95HdYg32sQX8jumj4YfOaxrNi51Jlhs++YaM+h8GrsLrW4+8uaXFFkcr5dtOLvvzIZN1qdP66euSnnOan5jO3Q+v5nOHacx+W6hVwICYj2veC6lnYjh+mztR1FckjSdZzQGna+2eadNAOULd+nQzazGE4F54V93G7ZGHZ8sDDNQj77k6YXjfCEwlr1vN9uA4Etr9trNPeeY2N2i9qiqzdEdMoutKEw9fU+8g+S3eek2bH5ccmpt8ukhLc/B19q77z7o5C0umJwQOLUnTNPpM3S+VKSt/rRm+2ygts6lQbe8e7rRfD/DbR6KRj96asIkVq0Bnc/3lfrb1UL/9NO5P8b4Szn2cQVHvnpN5XWGZnxTv+2Ryd/Q+by1HGtZzU22q1wNfDM6oL4iJ+tG1YnPb/dezckME5zMPEYcQzE/9t8/g3hRENdDiAxPCy+y84nHFyajLpH/sS7UZ8SIn3HiJqMuMdr/rS45z2CLjZ4riyrvZ13ppZMeuuon8iyE/+PN5V+eS2SnZAgQ/02Gj4y6xP/HuigN8kLO9n19yRS0O1T2fo7lJoWyfSdi9BnPJlnddHx4Yw9xDylIRl0S/2NdIlrx0rvkD3G+ZnHUz3A3jDn/9UL7G3W+Zz56x/e5jgWUEa95ETLqksSs698XDeY8on9/HVNgXFsUGO83BcZ7QAHXRUWoNfw+q1dqaCBz2uz3yabTgpvELQtPPzy+PPzx3tGckD9/YH6s+F8en7geouTcd4vcp4jHFyPnvqP4b64jCTCPNI+CifXUG59Ou+2TZ6njZoV4OjxSVZTpf9UXOkXuqNOC15GAetz3eKGZS1VKm0te9nDGCn/PtVMUetjIO3lLhYdlzh9eR6Je5Q1q2td+hRywT70QY6LeNBJ/hGPL6dZMoZtj2m9YGuF1RCGh150kdf6hMOea+PEGuQPHjCx3VSyxGNKTSKKQrXmSBa8j2q3sVeO/pC+PSzXTiT7WWjZR2nKDK4RWdS+LX1Ngx9Irf463YD0QLwriekiQc98v8nVEPL4kGXVJ/UfXkTSYh9d36Y2VliM7oqLzFN2y9LYmXs+fiA/7Zl1iHX/dWLGBE15HsmqzLw9oJBVWeXjtTH4SQsVuPKJh+5R7k2KA6GeRHmZ3eB1JTw6HehnvVpX7pD7A7+bVyiu3JG0o1NnnV8/s0emc11zwOhIv1KBksbx0ori192CkxJbrzVRSEdetkl4b+rWIKgs/5CTpR1GG3yL5kjdbcmXJu69SGnq5K/YAlSHP8D613H1PHdyd/7wBC9YD8aIgroc0Ge+XzCJfR8Tjy5BRl+x/dB3JgXm4l/MttT1nxajIIn+g8MNzR6F3dBdeiCcvyX1bcUPLdFoCXkdMx5arThNE5r60DsmxTXtw6HuNXrngkZ418SJv66GnMqHwOlKkdrMJEvGhbExO7S/S3zL19ZGfSLiYZfaTD5s0nP1/v4bXEaXN5HFLi2UXFevmqgTKVWmmnBVelVslyeUW6suE9D4sgNeR4P3m2XX7LNgnXCJzevXVXxPefdTacMLywnKL56mxPTJ/ftsV9/0iroccGe+X/CJfR8Tjy5NRl8Ii+/uPi8ioS26R/U3MFCly3sdF9jexR8mS8z4usr+J17wCGXUp/kf+VsTwN8a1RYHxflNgvAcUcF0ofb+aH/gQkFVtvveCHYewixzDrhT33ge3vOtvf3u+iqnzzx+YHyv+t8en+GdNcN8vpUXuU8TjK5FRlzLFf3MdqWD4Ww7D3/IY/lbA8De8jpROW63bdKy2iKd9A8Hx/IWVCU53HHbcLNWl7JviOtj4ePrP8RasB+JFQVwPFTLeL9VFvo6Ix1cloy61/+g6UsfwtxyGv+Ux/K2A4W94HTGf0pU2rUr1PhXC/9ZpdfWEWVSGTNbHHd8MTy0XadVqZ/vzBixYD8SLgrge6mS8XxqLfB0Rj69BRl1L/qPraCmGv+Uw/C2P4W8FDH+T5H3u1qPBTwxP7Ul5dLBho6f4STHT8mYWtg935To641ojvP+8AQvWA/GiIK7HUjLeL81Fvo6Ix9ckoy6tRfY30QDK5PTJRfY3MVPUyKhLfZH9TexRS8jpU4vsb+I1r0VOn/qP/K2N4W+Ma4sC4/2mwHgPKOC6iBrPKDyWWbXx0xs+nVn6XL+Hfv3LPpR9EqHSsaAPbN/4+s8fmB8r/pfHJ66HNhnvl84i9yni8XXIqEuX4r+5jpZh+FsNw9/qGP7WwPA3vI44LU+93ppf9PLYyOHMKl7blRK9mSEqF1jPERQHmgtprfP+HG/BeiBeFMT1WEbG+6W3yNcR8fh6ZNSl/x9dR8sx/K2G4W91DH9rYPgbXkdcLTr0WtYEl/oxzo+ffijuiBnS3u075vqh9fSKmAnhR+1/3oAF64F4URDXYzkZ75fBIl9HxOMbkFHXiv/oOjLE8Lcahr/VMfytgeFveB3xrqhesmlys6nzMUnz0++u7zc7HZGtxqTraBZMd+rgymCyco24HoZkvF9Gi3wdEY9vREZdxph1US84PsrfRAPA7ES5mNjrYY9EeZV4T8N7AeVI4ntnTMY6URIW9/379/+gXPDnKN6HJrl8UODPYX74vnlSJ479J8f9W+yvitNV5gY40xuf45yDCQU036tXR8se+UXydLaXr5CrXnPhGXPfBS71640NJfIH6h/C4hbW9DfnIv6XNZnC6+/bSiut79wX7IJtjx6YEaoL9aFvaaR37t56dW6cYevAvv/n4Bi1EM/ZhIz3e+X/eL/yfjHu1S8orTrYK2CysfPJkyjujoT2rs9b3lStMu2woOohnvdKMupaBepiqVTVkk/wjzlhrxDkRLMy6Qtrqbjk+k4Gv6s/MhOlIxv+b3WhToN4/FVk1GW2yP2NeHwzMupa/T/WpSot8GuYcnjZumtHny+5alD2ON5j+QWfq0YK2Rq8IVmzUuS+j+agLi5pth1i0w93ZTwu+HjUmuHc8S9ln7eUHbThX3Jox+XtCe/+b3WhToN4fHMy6rJY5PeReHwLMupa8z/WxXeoVOHAtkaZgBTWOfq7v2MbbXpVbftb87IOdac9H1HgIPd9XAvqUlvV+Dag8NEya5rrF5c0F2nrZ18YtjoSrvDK/cy3rTWMNf+3ulCnQTz+WjLqWrfI7yPx+OvIqGv9/1gXe5yfsdCtDy+y85kz7bVTsq4Un+JIl9YJm213tlO6xxFG7F2ryahr+f/491eofk+8F9eQUZfB/1iXUkTRLbYamnM/+fo7SgZUWSZo0/YxD0n7nBCMyt+g7X6YeG2tJ6OuFWT+vRo15jwb/v56ocB4Dykw1pUCnqu8v0HNUEZqwHmdw5Mnx+/qP88vkUu3qFK4NJETUiJvdfjPH5gfK/6Xxyee4wYy3oONi3yPE4+/kYy6LCn+m2tjE5iH4c1eE6PjLS9mntO6xL9dvsREMUBxt86D0oNmwQH3pMPd4bXBFvuGVVs3sOTi6tIeFWM63w/+Kcw5cqdXXfPhOzotcUcOXhvS14ePXDwhbxdi8mzvTXodgRxfMwGJTw/To2NEErqyz66C14acnJO+cu0Lqm/+Jbq9ZS0s4kuDrQgVVk94GOTTO3/VkvXvPcRz3ETGe2C1yNcG8fhWZNRl/R9dG5vBPCp74qZWJnTca3qyPSW6gnuSM6b04eNLpznLOPndyiW3BpL0jZd7zKa5piZPReyW+Hamb3WI28EHaZ/2Ps65KBS2tDztKbw22LuK6W0b3vNbu+rv+bB0e3QhnZJ2eXno9Ezb1UGTxmeS8NqQ2lBpf8dLrrx/zVMlRe4rdUemW1Zo0oS8eTx9U+OTfdWSP4u64BwRLwriOW4m4z3YssjXBvH4W8ioa+si24DYYy3JqMtwkW1AvL+tyajLaJFtQLy2tpJRl/F/ZAMbDBtgvIcUGOtKAc+V55GMJpVgb7hfsHJ2w6kJhzT2ezyMS32E62LnjoTEtMj/+QPzY8X/8vjEc7Qh4z2wXeR7nHh8WzLqsvuP+v82DBsYYtjACMMG8NpgeT71pu1Dzq6dbYmvgvNv9F1iPX9RyDZrSStFy0iD86uffxZ1wTkiXhTEc9xGxnuwfZGvDeLxt5NRl/1/dG3swLCBIYYNjDBsAK8NobrouXKO6RoHNrdd6YaPnD5vyPH+qSo2HHNmC3+S7/obfxZ1wTkiXhTEc9xBxnuwc5GvDeLxd5JR165FtgGxx9qRUZfJItuAeH/bk1GX6SLbgHht7SKjrpX/kQ0cMGyA8R5SYKwrBTxXdismxnyJmu7B0UkhCteK9dWHEw/JeEd589XGXKSN/2j35w/MjxX/y+MTz9GBjPdg9yLf48Tj7yajrj2LXBdxrfaQUddeUJe0puluw31zSXwmvq+jDBueOJ6Jz2O6cfvYGkm3G8Mjw+/hhAv/rR3Vg+A8qJr2gbFqv/b739m+0ferc9hbF7c5E+nuDJ97UfxzIpz2pqmHrHfA61tig/f+SvbTdJY+qscSrnbqeziYdvg3nS4bOSa1/iJ78S54fXN6f3B6wO4l/p6K0WFEU+FJT04Ote2w8EO7/LeN5/ZsaIbXt0BhjJf3Mf1zV10C9xGcNseObai+VLvV9ku9i0GsSw7HNXLeL+I57iPj/dq/yNcR8fj7yajLcZHrIq6VIxl1OYG6JDMtpn/v8E2okzkkU3ra4O1wUcbhkTqqVOoiAbH0lM0ccELaBfNQfKSb3n977Q2uwXV3OMKeKHnMUW1qNFqvLXe3pd+dt3kVvL5R94ITxr3gDMaKPDzYf0/25mtu66m+1vLgVLG9e852GhuuNK/S0eZRPt8G7wW1Cj2/SS+Fu9dr3kvFvwsz3uJxyzXFrHj5C6F2varrKo/gvcD48PbFZVbRh2hb6UdurP5g/8uIPuhB/S+rC8uoWZn3m56H9wJb2a2xKZ1Dodv06MNPWM1SZHxS+il0eM+D3atP6ly1C48h570lnqMzGe/tgUW+5ojHP0BGXQcXuS7iWh0koy4XUBf3dLPfvfQjG5i977BEVUsxm3lNxOQucZeamCiNKbsi3gMnpFswD18PX8gvy1OFn6IDeuO2awpwVNk8Ot/VUXH884k1diJvbsJ7AXXfOGHcNy4Y980hMJbN4orb/ZlsTnu+DxGda17q8zy+ILHFimnnMc63QR/7aFjgfcNNpddlUHChsyQx5NHqgLRIr11XFXd/0l5V+tvw4g0W/S3wvqHe9uT6J+1jxt0vTlbamib3+ZwWeqjcRh1+89Z3o2t3b+2F9w1nOEV0xq29mzkzOyaHFQYoM8rCMyT8lMML6uj6w/f/3EHOdUA8x0NkXAeHF/n6JB7/MBl1HVnkuohrdYSMulxBXTz3FcKKQmU0W7JfTFd9GDU+Z8K8IWes97PkVEpv2LZPMnBC+gXz0Ltv0b9iGDl9dA/VU9PGGpWvB9spvSSe/S6+U7Fis/71V/C+Qd1jThj3mAvGPeaKcY+5gbH0fFaa90oJUrK7An/tmhh+fJE65XzHo6C9K5uVhrwyxFzgPcae9C5/63BPWNyhafFPv/Jf8BS8mHAM020sLn0r8zvbjgbeYxKXBIUzXseVJ2x6EDBxe59I7PW+qIztgbb2z7OjdsneCYX3GHM8pz67vphckGBLzPqic3PLsnT3Sane5WtgNX6Wam/A8GetFrwniBcF8RzdyLhmji7ytUw8/lEy6jq2yHUR1+oYGXW5g7rUTvfvkupMTZbkkhqqz/7+IHDkl2rQhuOm69REIrZKLnkCJ2RYMI/8D//GIQU/gpNkz/SZpWWndvUEfvzW6nOVbifVSN2Vbz3wHkPdj04Y96MLxv3oinE/umPcjx5gLKOY1D5Klbg2832XtzNX/Uhvk/i+nPbj0wB2q7h122+mrYb3I4VrfLixH28Uw/URwckpXxv5H3bFA3zjYzF53y5G7do3Bu9HjvfhV8e0NKRHzq6vWD4+3DcbLnZGktXSJZEwQl/gm5IL70dB6v5WQ6c3B5fb3JU6K5HR+OUtf3AFe31JOWOHhCa77cifuRe8f4gXBfEcPci4vo4v8nVPPP5xMuryXOS6iGvlSUZdXqAuqoMrl9xzltf3TuQZWLfmY0aNhKvar8HsT1K2Gz1O1NnLwQkZF8wjdWrMXL+ku3PbeelfAj2P015p35I5v5fS7JSr4/H7t5oD4P2IunedMO5dF4x71xXj3nXHuHe9MO5dbzCW816lsHiOmeF3jseVh31vsjNutXj545l1Y01R3rWD9S6SJF7daCMixbpeKmq9++a371rTMt5T3xvR96E0tC4KNlnSkATvXeGhisxhiYtNqQwXB1fe96rpYxTkjD/N9lL+YNHoCaurn+C9K3zuHVPQ3fR3dM4/Gn2Lg5dOM11S491/szhUMMZJyKSGrH/TJ56jNxnX4olFvkeIxz9BRl0nF7ku4lqdJKMuH1CXxJlW74MXJtnfe0mcz1rD8bEvYflVNY4BhwzhrQHVMV32cEKmBfPQeW9axWe85Q1be5nJjCrjdnaTwVH1T+zLnvexR5i/bOOC9y7qPnfCuM9dMO5zV4z73B3jPvfCuM99MO7zU2AsJYv9zg7hXp/fWhoak69YGq5YXDT8MNDpt7Y3stj7zu00koz+Jv6pxfPi5Qd7JaJHnGafxRZ7hihsz19xT/rzlaR97kPwPldm/kYo6fN3o7q59rvbFc1tg8enDU0DvcwyfpUk99OueAzvc6HxZYpH3t7Re3juA6PHmdayb246Ml3F6vEMr9+XyXbHKvyZe8F1gXhREM/xFBnX7elFvp+Ixz9NRl2+i1wXca18yajLD3pP9tKkm/uRocbaLcX7WNxHdLxjqc++pKq3tpHyGpmb/AAnZF4wD1d6bsRsjunTqHvDM6s9hKT2vPMTOaq01ZyGcLC344xvKrzPUT3BCaMnuGD0BFeMnuCO0RO8MHqCD0ZP8MPoCWdgvWFC3XsZjjiMhOoprJKxkBD54PFpPRv9dbVdhCIxR/ljJPvo9lNKyi2uGU+0Zk792KaSa9zoWGsiyJUw0VWfkRdYVEvy7x0jylwtjYTHY+kiIYQmO2mBAp+sWzOzaR+qubh5HuX5wp7AsKShQEJIj+VGdItla2jnuuNfOx4XJR87vK6dd5ctlz9Zv0lPPMczZFzj/ot87xGP709GXQGLXBdxrQLIqCsQ1CU6OtorzPTBcaNCLJUYT6y5wmDAwAtWBtr4X4W9zgzJ2XBClgXzsDMFnX3nOLy2W+Se9vi2raGN59w8KBN2vWGgVOzSbA82gj0B1T+cMPqHC0b/cMXoH+4Y/cMLo3/4YPQPP4z+EYjRP86CsbJRv32q70aPrw9+l1umcytE6b7c5S3BYYGrV6dljTysLoD9Q8BO4kzd0w2n7ayHFaU+ZX2nqrn7tq+tQ7Zi/9q4DB5vdtg/hE5p1E5VbQ58zrSVp3Jlbufxu5GcL0UNhp9rGivXP5WUg/1D5dGS08HfbrVeSxxbc3jyjKYj189k9tov/QcOJX1ax/LF7c9aLbjeEC8K4jmeJeN+CFrk+5R4/CAy6gpe5LqIaxVMRl0hoC65AT8q/Vc9924kXx2o9ZrVWxteYHCdQ+HK/qOJFQ3S66zghKwL5qFR36msNDxYE/Yyfz1/gX59nqWoza5neUcos75lXnqlN0ny76WIXuOE0WtcMHqNK0avccfoNV4YvcYHo9f4YfSaQIxeE4LRa0LBWO6UJ2Zv2ZeVBjs9i/e/JTBDOP+05JC/kstF/8Izu/v5HsBew2P74Whb+uBj+pVzShcmWAW3xL91Eb3n5f2Y42OPWlilDew1XJ56ieUUapmuWkaKy6fjztEcjf768dwLeQ9VX7FHy5akwV4j9vpCzIYW54ggG7ZgMdX4445djL+UgnxcHo2WmvHtZ5/5s1YLrk3Ei4J4jqFk3DvnFvmeJh7/HBl1nV/kuohrdZ6MusLg9WxxfsX+2FnppRI/Th/arBUae6LyV1Ni79km7k1nLnuPLIMTsi2YRzxTsJzn5xLt7RM8/rsvnRtkMk9KTtvzfa4m1Z7hpc3HHNhrUH3JCaMvuWD0JVeMvuSO0Ze8MPqSD0Zf8sPoS4EYfSkEoy+FYfSlC3B965dISdIFHSsX0cnp2K1w3qKhz2/1rTjW016sd5+asI+SfGbsZVpvlYGWa0KaSFmE0jjhJHsljfP2GdrXLvVGSit1jGFfYt9evyI6jHbZyeTS3A/eiVpXh5VLLkjsMt5NxX5vu8iNn7Av0bxuvck3Z/9YW/QnZUX//gfuBQc2JF091HbkMaNgoWdD/Z+1WnAdI14UxHO8QMZ9dnGR73/i8S+SUdelRa6LuFaXyKgrHBqoNElsXcGs02Dn+lN9OnQT63e4vJTaPsp+8bNQ8dOPdKlwQvYF8/CWWzczhCjlca1y3lcunGDkpF98uCnEwZSr6TttX3uND+xLqB7mhNHDXDB6mCtGD3PH6GFeGD3MB6OH+WH0sECMHhaC0cPCMHpYOEYPiwBjJdfdSbWUUTKZVRQZ/r3XKYV5+/f8NiU+tuRWf8boKEYdkn8DUimtX8b43Xtb/YTodQrG6KW67z5nbRQ7W1oR2/eQ/zoz7GECAr9Ozzy6zfemenZz7G2LESurMEdBiyVV9bUncu9IZQzBHqak2Rv74qH/to5JpdbXRzYqiVUzNcUls2gqZqwQqpT+83Of2Pck8RwjyLgnLy9yryAe/zIZdUUucl3EtYoko64oUJfYcSkG+izjXEcdqTBOtmq38fGMgB2W1GUHT12eFcmQZ4MTciyYh/V4xU6mk1dq4spi19Vq63gVyKw7e0lutNhrbHNXXqTbV9jDUP3OCaPfuWD0O1eMfueO0e+8MPqdD0a/88Pod4EY/S4Eo9+FYfS7cIx+F4XR767Afud7VaLM7K0a/+bHx3e1ZAY/XbVxTbWiV9aPE7RiKlX+R2G/41RsoeSQ3NWWove5P7+i48bTItlrHY7ce06ymGXNsN5aAvudzK5Lwuu1HlH88PTVNWhNVd1gzX64vM7TSyWDoyxtetcqks82X5iK4VsVzNWze0Tk8sDq0ylbvXgeC5icjjl+vPr0Sqbzf9Zqwf2BeFEQz/EKGfdv9CL3FeLxo8mo6+oi10Vcq6tk1BUD6pL5df3ytUEpXp/CQCGeud8qPjE5t86dubgh6+utoOL3vFvhhJwL5hHspHizI+3CL5tbt9drK0W+neJn7np9sufK5a0R9xxN7t2H/Q7VG50weqMLRm90xeiN7hi90QujN/pg9EY/jN4YiNEbQzB6YxhGbwzH6I1RGL0xBqM3XoPnJiKpPjlueCDP2VapsDTpy+OJg5J0s/5MXqa3UmqPNamRfMfPdfu+ponTN4U+bPiq6NI5zsqZ7qtlGeE7GU23d0JsogD2RrZAu5RxpuhwPlbKtdkshYfpLnlxftI9rqlwIJm698VFatgbmWrk2qIrH+7/aPZbII1N6IqiQdsavjOP5LeUyZ/lUd9k+2et/r1+CX/1oiCe4zUy7vXYRe5BxOPHklHX9UWui7hW18moKw5eo0IV/IOf7cQbfz7oUHoka2dgsHX40qt1TnsUPCTD7hOq4IRcC+bhUUvbLJlZ/6HMiiv7lb3e4SHvHH4Oyu7dx/Xe+3TP+ZvD3ojqo04YfdQFo4+6YvRRd4w+6oXRR30w+qgfRh8NxOijIRh9NAyjj4Zj9NEojD4ag9FH4zD66A0wlrFMwXRS65tY4P3w7bYHRrdr7Mzrs2FrcmBJpBCjqoleAfuoZGXfa64mH6MUTaGrV7jMhQ1/+3f/Wk1flyrKXt4tHPmBpI+uz1AUTHy/LuNLjuQR6rqzptGfWM+0J0isWjv9M/ht5DbYR5Vfq9+24Utw9skYmND5dFSvMr2fNqKqXrMuSXoJm9gJrz9r9e/1S/irFwXxHG+Q0RfiF7lfEY8fT0ZdNxe5LuJa3SSjrgTY3/i20tGe3uQeU7Z0Qy1FzOah0udWiQ0MomUvK5fQ3VvuCSfkXjAP1cmuaxeFGHbHRg1vNwu18bpYdzvRLLjUouy4i5uUlk477KOonuuE0XNdMHquK0bPdcfouV4YPdcHo+f6YfTcQIyeG4LRc8Mwem44Rs+Nwui5MRg9Nw6j5yZg9NxbYKzsmFuiMC/blv0On7aI/Np3vlDqzG6Zq4ZXXncnOH5t2PoM9lzm4GpqkeqDPEK+y5O2Nuoyxb0nrD76Ti9cmdOFIvDGqaskz6e48vqzraLnWU/3j7L9B39JOqRcWjm7XNPi5jrrFZuv/uYg2ddHO3F8eZYpsTPJSUSYJkXl89i2I7nHDo4NDRwdXF0jGPtnrf69fgl/9aIgnuMtMnrI7UXubcTj3yajrjuLXBdxre6QUVciqIuN8uunpl03E7uyV40NVPiPuKjmnClc86Os8m2MG8+OMR84Ic+CeWjW3kpxUsqI27eisOBO250PWaUbTlFePufXMsdapd1p5gJ7Lqo/O2H0ZxeM/uyK0Z/dMfqzF0Z/9sHoz34Y/TkQoz+HYPTnMIz+HI7Rn6Mw+nMMRn+Ow+jPCRj9ORGjPyeBsczvzIutVz3vtQgb3cB3vFpKJGdz23A395Mt/t0XHuVYRcL+TGv9U4763e1bEc1XOQUv5u6jYdw820jQ3LWz8eGYSWzqA5J/K6cujhc7PUi5SppTQkFr6OuVlZkT11zzcz5sez7766iXNomJ91iL5FJd39i8ma2xe/39H69WNK5Lijh6sl3nEn1n8cU/z53B7TfEc0wio98kL3IfJB4/mYy67i5yXcS1uktGXSmwF4ocP/kyQCeT/u1dp2NUw1cjt+74sDXDO2HMNodXf5n+Czgh74J5ZC7tu9Mu5r/nxcupCfuS2v7HoUcNN1u587u6JOzI05R6SvIZHkQvd8Lo5S4YvdwVo5e7Y/RyL4xe7oPRy/0wenkgRi8PwejlYRi9PByjl0dh9PIYjF4eh9HLEzB6eSJGL0/B6OX3wFgWFu0zJTQnjvhxrvXUFzG5evy5ltIN6hvLxL24kq6IsReSfGaA/oa1wMqJm49MYwYeLLspyRLIobY/sHntnHI/83GmkGySXh5u/C3t+a7JZw/32H7b2VtxN3R71Y5jenztvvTupR3318BeLsnB+MHjgdzSZxGeU4X+Whc97pUn0F1ec0fO8QFXdIq0+Z+1+vf6JfzVi4J4jvfI6E33F7lnEo9/n4y6Uhe5LuJapZJRVxqoS+ZQm82pz9zqFj23ZwnOneL0FmdGth/3jkiJ50q8Kz3VAifkWzAPz9arCYaFO0z61dTKTK5J76ExoBelvFb2U37Fle8jGz84wl6O6vtOGH3fBaPvu2L0fXeMvu+F0fd9MPq+H0bfD8To+yEYfT8Mo++HY/T9KIy+H4PR9+Mw+n4CRt9PxOj7KRh9Pw2j7z+A16+lp/oeuT7dGxwjFx0uZLoy1oveHXxUpCax6l5PELUDJez7VFnjpnevWzgareKO4X4W7JkS7S+qzVFi/XboCc91Jldz2PdVjas06S/pK39NZZrKMzX/fkjeMpVL6vbEh+bYmh23QltIPu96ZBuv1aehwQk54dEA2tMKtMeTsqf27SihV5BX3lTuSNazd4jn+ICMPpa+yP2VePx0MurKWOS6iGuVQUZdmbBfcKVl/hTYmRS6NMsgmZX+7GrHgIrpToHNMY8zgnujTu2GE/IvmEfazGX8p9gGS83gw6e2m4SlRNg+Kdvtm7j3gz8/x7WXLDwkf6+NyAgnjIxwwcgIV4yMcMfICC+MjPDByAg/jIwIxMiIEIyMCMPIiHCMjIjCyIgYjIyIw8iIBIyMSMTIiBSMjEjDyIhMjIx4CK9fkX1BW5Ss4uuXc+yfqS2zkxR/cm1Zs6roxEOhzUV7InhhRrC+ZF/5yFimv/jy7bsn1tBrrnpWRbu0/eCG94en+WsOvIqBGcEa4X7RWm2b1y/apCtqpSWexzea9tcek577TnHBkH35ykMwIxjjL6ooOxzTnzp8tyz16rvqokKfx9xFFsLsT0rPnb1ETdbniYnn+JCMnpe1yL2YePwsMurKXuS6iGuVTUZdOaAukWi3Drc7NGOuuyk3jRxRPbNM+sjZDw9WBga/ii+s/HB3C5xQYME8vDHBiQ/6c1d02GjYv+tjURmueXr6aaHlypcbJ51ndC6kkTyPGpEnThh54oKRJ64YeeKOkSdeGHnig5Enfhh5EoiRJyEYeRKGkSfhGHkShZEnMRh5EoeRJwkYeZKIkScpGHmShpEnmRh5koORJ7lgrJyC1IiduMyBsgTl6SddHMfs6w8U3c0vO/0qeHvYmiMlXiTPGWCfujQxqcFpv8vv1dZHVe+W63TEjW0oDbW4oXuii3HpC5gndHMVlemEdJv8M/KWZ5kqZEzyh83Yr8corXxXum9SvtML5gn9Z+/Sl8fuKL1dtmk1u/crU+41Cp+HnE8rt3E0BAnx5Ib9Wat/r1/CX70oiOeYS0Z/fLTIfZt4/Edk1JW3yHUR1yqPjLryQV3835IFVm95/Ox167eS86muW0enKVRazzbspN4wbJmd8ILk75oEF8xD8bF0qeoNa55H+9dxOemPnnlZnKrR8+KkyuhKj4siWY+6SL6fgsgeJ4zsccHIHleM7HHHyB4vjOzxwcgeP4zsCcTInhCM7AnDyJ5wjOyJwsieGIzsicPIngSM7EnEyJ4UjOxJw8ieTIzsycHInnyM7HkMx8rejij8HawlMGPOWlM/p+IdwyfalL1JNU3n4LZY17p9MHvo9g05drw96H1hIF1N1En+xU4vYx1/R2VmFa0qrs3JPIowexg8JGo0lcp6Jc720xh6MdSedcxpog4ti90zVR04+jaLl+R57rp2Q32lr45Ud6Z0skRsDe1TjmYd27hpo199co9fXdOfj/zh9lLiOT4mo5cWLHKPJx6/gIy6Che5LuJaFZJRVxGoS9bFOo9n1P1B8H7O0ssfkr5PrX2YefXIuPhb/71Sl4ae3IMTCi2Yh/7p5qE+17Z1X2QpXRhafUJuPn/hWlJ1dpzXcmboWGleCenvIPx/55QTRk65YOSUK0ZOuWPklBdGTvlg5JQfRk4FYuRUCEZOhWHkVDhGTkVh5FQMRk7FYeRUAkZOJWLkVApGTqVh5FQmRk7lYORUPkZOFWHk1BMwVnGWfWsYz7JKqnL6t5a9r88vrXha2ckk9/slK6udw1WDBJhTSlty3iQ9LWIef5TbGEPHVyBdROCd7L/vcsvkp6v8z5I+kmewP3hx5cNvzvW3jD33e582UhvfUUcIiFJ73UZTyyfUraEGc4p/9Jmr84UmhyWfWesFFQ4PrTtwrOfGiFlc37Ylcc9KN6X8Wat/r1/CX70oiOf4hIy++3SR84B4/Kdk1FW8yHUR16qYjLpKQF0qe6XWRdKZnk9Suvjec2WppLP6+tnHz68LGm58M6C5pmcCTii8YB4V9yNJVo+dqerWm5xRODDBZkSt+unFvt18HoNU/mJyV06R/CYCItOcMDLNBSPTXDEyzR0j07wwMs0HI9P8MDItECPTQjAyLQwj08IxMi0KI9NiMDItDiPTEjAyLREj01IwMi0NI9MyMTItByPT8jEyrQgj00owMq0UjOVM+K070FErG8sXMiyqH3wiaIvUdZWh47kUbHIvPzJeMYCZJircdu+B6weLyPaMmi3b1J7Xl9i/Oa3vEGp5Nar4SkS1EMw0uZYjL+4/EuhbXqpmytrlu1OZPq1FvK9pVZd72KdS7idxJM8sH0hqDXBnFJw8c+yV25v3Fq2/n4ZsiejL66SNOU5D62PzZ63+vX4Jf/WiIJ5jKRk9umyRs4N4/DIy6ipf5LqIa1VORl0V0Ec5bMWbRiye+Oh1vhe4+/XRdIGn+M7Jbl+CxLsR1y1VUXBCkQXzCNvwr4kL49fcMqgZ3PJTw+5wds/yBw4Tec+KV3YE3/TphpmGyj8njPxzwcg/V4z8c8fIPy+M/PPByD8/jPwLxMi/EIz8C8PIv3CM/IvCyL8YjPyLw8i/BIz8S8TIvxSM/EvDyL9MjPzLwci/fIz8K8LIvxKM/KvAyL9KMFZYdrWnM5XJxXdP604pDm86umfOvNH9vODdrjehox9fMZN8h1zh6gc1w2fpkasCVQZurqS7PsSqWHH1jjp113T3tOSe5M8kn6PouLU9hNYj7+36ye0Fwx/UpaxFbmi/01H+rMe1r9Q28yLJ79xtzFve/8VwauiYHQcP34QiXeUm89jYoyn7vksevvXhx+E/a/Xv9Uv4qxcF8RwryejnzxY5Z4jHf0ZGXVWLXBdxrarIqKsa9reRw2tXFEc5dhS8/HDuQEu3SKXik9fy2W60FyPppg6uIvm+jOiCeSi3TI6OfjKtHgvb+Eql/1PZ8NTVscpbQlkP12RrFokxysD8Q2WlE0ZWumBkpStGVrpjZKUXRlb6YGSlH0ZWBmJkZQhGVoZhZGU4RlZGYWRlDEZWxmFkZQJGViZiZGUKRlamYWRlJkZW5mBkZT5GVhZhZGUJRlZWYGRlNUZWPodrtoZLh2b9FgtLl4P3fVO53mdpsUw22zVn6Nxjae3efP0MyXOrJpU0hw6w592pufU4t+VHsWmAG0/Fyk2XV03nJxsczkgleaZf7nUL2RbLlqx1mTuZa0XshEPK1YveUrtXs+XOygRwSMGs5F3rU1nyjd6ixvB9Pa+1KI2e+LGzl1py2EeOGqur//54889a/Xv9Ev7qRUE8x+dk9P4Xi5xJxOO/IKOumkWui7hWNWTUVQvq4r+ckXa0b+25bSdWqdruyxDh+OFpVsWUs+YOxyupnwxWAnBCsQXzsAdsk4/zT1ZhtmtU3Hd6RPTd78iqmTbz8uaOh0t2tApvh1mJylUnjFx1wchVV4xcdcfIVS+MXPXByFU/jFwNxMjVEIxcDcPI1XCMXI3CyNUYjFyNw8jVBIxcTcTI1RSMXE3DyNVMjFzNwcjVfIxcLcLI1RKMXK3AyNVqjFytxcjVl2CsLN2zpP6X3OPLJKr9rqV3HQ+0i9j5tOPqbhHePcpfHoxEwVylV42JVVlTTh2uqq9UGzoZM3ny2iv3Z/afu9+HSa9mcid5NjjVS6UZFsF3z+KOfaJV5B8I5OemNZcvz3LI+GStPXTm/VaYqyJmr74aHVh3ZpvCsxtXVsZcXFVTu2+30/2WzOClPN3Z9nv+rNW/1y/hr14UxHN8SUZO1C1yfhGPX0dGXfWLXBdxrerJqKsB9nkLpV3RpQ9D9ukMrjWmqLrM3+sia+Ml1JxSk0bxnD91LZxQfMF/eY7e8fSre3WMq9v9uXHud665Z99XBv3usL1lflxwbg2FAMlvPCEy2Akjg10wMtgVI4PdMTLYCyODfTAy2A8jgwMxMjgEI4PDMDI4HCODozAyOAYjg+MwMjgBI4MTMTI4BSOD0zAyOBMjg3MwMjgfI4OLMDK4BCODKzAyuBojg2sxMrgBI4MbwVhJ6+1PfXiaojYb0UepVW1w3dmwLXzqB/vJU2sGun5v1LhI8vfAujaTqa+Kax9csnm2i5VnMHTJx2OcWrajkWtGN+oZ59PCDJbVnz3p48C5ZbBQfnWuoGDUe9p1Ox3cSrPzCyz2vw6wI/mdRYGqmb2dwXEGSx+6T3zX/sWtn+5YekjBQfpM0TbflXknyPp3UOI5NpKRKa8WOeuIx39FRl1Ni1wXca2ayKirGV7PxyV252ix+QrpKwfvvfXG5KqZvISBYxlj9u/uo09+fwqHE0osmIf6yQ8B7RW/ui0m0ie0vfguFmzrHnw488nFst9D0bpDzpnkO9eIvHbCyGsXjLx2xchrd4y89sLIax+MvPbDyOtAjLwOwcjrMIy8DsfI6yiMvI7ByOs4jLxOwMjrRIy8TsHI6zSMvM7EyOscjLzOx8jrIoy8LsHI6wqMvK7GyOtajLxuwMjrZoy8bgFj+Ye6g8sK9Pg8N8jEKVu9kd/3acWE6hXXM7zVVZu/WXOow7zm3baHvqVQuvR+7SXGWJaPfMmXnvc8s6NpsQg08J+qcn8D81q6cKiBy1lppUPNuaSd57Opgz5W9zxN8But8LZZPmhadRnmNUeg5O3Y1UM/VMdltz47tG7Ke3vGd87OhskBusvJttwrVP+s1b/XL+GvXhTEc2whI39eL3IuEo//moy63ixyXcS1ekNGXa2gLsY8zygbyfc/T02fjbq0e90htZXbL3Jf/Gjq3PD4FyNhLAVOKLlgHgmuqKS+4nsye6pocz7se2pr4/ezy/Txbe0TR+9vfSLOdBHmNSrbnTCy3QUj210xst0dI9u9MLLdByPb/TCyPRAj20Mwsj0MI9vDMbI9CiPbYzCyPQ4j2xMwsj0RI9tTMLI9DSPbMzGyPQcj2/Mxsr0II9tLMLK9AiPbqzGyvRYj2xswsr0ZI9tbMbL9LezHqq4WJfszdmSfGZfpTHoyEli2a9W31HNCDQXOKsdMIw1htsu8ib/XwnZl6uzHJfk7r9W6xbNFTvffZItkjRejqXz1vgVmO9/BmbaMSTqn25fpZp9dP3lgLm5y/FFXVO1TSQsHptEWCZjt8sWa9V5aDpmCS8P6077fa3i+XHRF/pdbZ6+OP5Osqbvf9met/r1+CX/1oiCe41sysqptkTOUePw2Mup6t8h1EdfqHRl1tYO6mNiOrVa6rrZr1RN3Cr4v1z86G5Z/ei/X1zLLcnsiVdP/HJxQasE8XFLmjdN7QgtWD2iEFQj/sJs2ObFnNMr0ssIXseXb143NwmxHOcAJwwEuGA5wxXCAO4YDvDAc4IPhAD8MBwRiOCAEwwFhGA4Ix3BAFIYDYjAcEIfhgAQMByRiOCAFwwFpGA7IxHBADoYD8jEcUIThgBIMB1RgOKAawwG1GA5owHBAM4YDWjEc0I7hgA6YKcFrxa9lxZm8v2grslLG6MKyCE+N60qdPYZrX55faca+HDqA70Eu93m6zl/NQwHMyZ9lY/ZZrT5ydb/fli3CR55s2FX4HjqAc6lEwLGwqgfUkUV71a8lV057Bgxc9z9kqL5EOnvdiYMkzySScVq3o0FuKPiFvmTquKtvRZvwQ/51pz2PD3iwClCPaP35GgturhHPsYOMXOtc5LwlHr+TjLq6Frku4lp1kVFXN+xDqa6R7g9e7xUWFxG0mtl4vuZ7No+y3qdurpTzm1Z0NB+AE0ovmEeRQ090YmXp1QjLS65rw0+FynPZCrWdo/tlJ9VbeoQu8iV0AMoMThhmcMEwgyuGGdwxzOCFYQYfDDP4YZghEMMMIRhmCMMwQziGGaIwzBCDYYY4DDMkYJghEcMMKRhmSMMwQyaGGXIwzJCPYYYiDDOUYJihAsMM1RhmqMUwQwOGGZoxzNCKYYZ2DDN0Y5ihB4ylvaYsevKku9u6dKZLug9qRpMSop2LdA3koz3vpF4I92KAZqBUdlhzhuWbv3tzdrC87ZqoALXjHVs3vTri5d/cSLe2vhWagT/b9Y7l0Uv7TTfrFPTtZNDokqfS6tjCIW4z09wbzC6UB83AEpu8zuTTvdBpsYRbAT9sTRvyXUu3b/2WmTwV+iG9gO3PV39wM5B4jj1kZGDvImcz8fi9ZNT1fpHrIq7VezLq6gN1qTkUhHzS5h7iqpAue3v0yMOSPW1ZW5qW+CfZ07+W1qpzgBPKLJiH3vyrZlHt91DWrAfOp9//rk2z/0pDHd4dfIzy99LLQq2u0AwoXzhh+MIFwxeuGL5wx/CFF4YvfDB84Yfhi0AMX4Rg+CIMwxfhGL6IwvBFDIYv4jB8kYDhi0QMX6Rg+CINwxeZGL7IwfBFPoYvijB8UYLhiwoMX1Rj+KIWwxcNGL5oxvBFK4Yv2jF80Y3hiz4MX3wAYwWunan5HM95o8n/5w9GU+5vnDfSP3Vn1WW3Uit4LKuxv0Xy+4prds0k5Cnr7+PN39u2P6vmoPNY7WEvH217Tt8WF39/FZLf5OoyXxIqd/DZNblt62h7tjB6C8ZZ9YhfVl16enfyGW/fE9AX0nNr2jI15g4GUAo5jew68uqw21ob1R2/vm++FPFSl9JN+c9a/Xv9Ev7qRUE8xw9k5OXHRc5x4vE/klHXp0Wui7hWn8ioqx/Uxd+0pkekK/K3J22R99ktG+K/1Z57aPKD/nd8vsupsmxOTjih7IJ51Byflz0XleFz8kphqBaYEtm+7XgF3236L9/WnKLiMq0LI3kGGMIiThgWccGwiCuGRdwxLOKFYREfDIv4YVgkEMMiIRgWCcOwSDiGRaIwLBKDYZE4DIskYFgkEcMiKRgWScOwSCaGRXIwLJKPYZEiDIuUYFikAsMi1RgWqcWwSAOGRZoxLNKKYZF2DIt0Y1ikD8Mi/RgWGQBjORzuHLW7JpYTEDPycNY3hspSQMPqTMnbaMbZkcq7axPjSb43KPiIr+WWqfvVyLnt8vt3OS4JF2hppVlCy8p8JHtSfDIBWkQwg5VGdLS4pFhblidRbIxG47aRnMeV8totzk5b34j/XEvy7JoEvl3B5UNn86+stxQaWVFidWqPY1JvjPE+UYm0hiOCdX/W6t/rl/BXLwriOQ6Qka2Di5z5xOMPklHX50Wui7hWn8moawhm7oz+hGufqNpFr73uXCwT8fwV/Lu6eaKu0vG0HFs3lxwMJ5RbMA+L+pmErjXvzhpa/qR/4Lg37wz3jUgplt3vcj4l2zdqUcZAi6Dc4oThFhcMt7hiuMUdwy1eGG7xwXCLH4ZbAjHcEoLhljAMt4RjuCUKwy0xGG6Jw3BLAoZbEjHckoLhljQMt2RiuCUHwy35GG4pwnBLCYZbKjDcUo3hlloMtzRguKUZwy2tGG5px3BLN4Zb+jDc0o/hliEMtwyDsZyfzyexl9M4vN1tLyRjpHblUE+lVJPpU8EDwnLc9GfefyD5riW9SwvtYLqupoqrYTjv3Ctvz873Dhv4CxTz+IearrLLQrfwxOt9bLqrKSj71FQqPjqOd4+DPN/kT/1jO/NPTi4RpKyGbpG9I/5cYv3Flg/sGm+Pvtni9ji/rtqkPMUv5+UVkV+6SmT9Gw3xHIfJyOEvi+wD4vG/kFHXyCLXRVyrETLqGgV1sfD/fGRYFW3W0OnEZOyu1H145CZtNqdD1aOmPW5mF0sC4ITyC+ZRPXQymonXbf2HglN+bAPbWDk6zCSfxZ6+/KrxxglD5RuHoVtQxnHCMI4LhnFcMYzjjmEcLwzj+GAYxw/DOIEYxgnBME4YhnHCMYwThWGcGAzjxGEYJwHDOIkYxknBME4ahnEyMYyTg2GcfAzjFGEYpwTDOBUYxqnGME4thnEaMIzTjGGcVgzjtGMYpxvDOH0YxunHMM4QhnFGMYzzFV47Ioc/XKo9qvzdXE7w3vqbp2d0brrPvGN4eGtkSQG7QX0WNA7TVqbPKXbbV5hlXNDbXng5fer3+AvdUv+qtg3W6abhz41Inqs//HzfGqV8wuZDbbPn12+wmRFdlioW+CbifbzWpjVrawVInqs/tYU50dfr0snrsav9kuVbX5S5pruLFz7XL9n8IOXeL/M/a/Xv9Uv4qxcF8Ry/kpHZ3xbZEsTjfyOjru+LXBdxrb6TUdcYrKvQROM+/ze9+jKxwim+Z5KGYm65dQ9XUbkmt1Jvf8UqDSdUWDAPh8WpY0PTuUJdGWGxL+PUXltl6qt9vS/meXdj7CvttI2N0DgoDzlheMgFw0OuGB5yx/CQF4aHfDA85IfhoUAMD4VgeCgMw0PhGB6KwvBQDIaH4jA8lIDhoUQMD6VgeCgNw0OZGB7KwfBQPoaHijA8VILhoQoMD1VjeKgWw0MNGB5qxvBQK4aH2jE81I3hoT4MD/VjeGgIw0OjGB4aw/DQOMwL46eaKbXiobJzDQc/Mq7L2pFyUrJs1dAZ7XT2bwcDTGqgh6j31wsYV679eaG75trxq6si4wc/L/U0Cey9JeFgYrb2nCn0EOPlJc9MxkRf1edIh679cnzz1cOyl72rpWLCNm5s8by7/Bz0EB9fzVjzOv/4mQydSdfpu4+KpL7FzdE4ld/korKSKdR/82et/r1+CX/1oiCe4zgZ+f5jkd1BPP4PMur6uch1EdfqJxl1TcB7Ndc2u4e5tYqdIUidd2//8NLnsu9oteZEiztZ3u4Wz30OJ1RcMA/1mamlR99atN5bmuwprN5QSVWnG9h2P4jAZaM7wOwldxt6CGUnJww7uWDYyRXDTu4YdvLCsJMPhp38MOwUiGGnEAw7hWHYKRzDTlEYdorBsFMchp0SMOyUiGGnFAw7pWHYKRPDTjkYdsrHsFMRhp1KMOxUgWGnagw71WLYqQHDTs0YdmrFsFM7hp26MezUh2Gnfgw7DWHYaRTDTmMYdprAsNMkGMsW4bbniH3uecPcnSWVq91l+2hWefTNGlcYFtlsV/2xzAnaiUOPx2jfZNCO4DWfbS6bvYw44iXAwC3DqWvyOO5xj87GUGgnhcwLtkvzw0dZI5mPR7ioi+p6Bzbubmzea5C7mW3WXzMZ2kmuoYTbhC3DV22crc37LGfajUvfJYwu94VqexgTDlk3hfxZq3+vX8JfvSiI5zhJhgV+LbJRiMf/RUZdU4tcF3GtpsioaxpmmFZ52+ECto0Otv2uPLeey7sUSr//YpR1aHjZ4G+fVJtYOKHSgnlYhlluaqr7fTntFH6j7FU05TvFe6z72yiZ3zNfde2oMS4ledYZwllOGM5ywXCWK4az3DGc5YXhLB8MZ/lhOCsQw1khGM4Kw3BWOIazojCcFYPhrDgMZyVgOCsRw1kpGM5Kw3BWJoazcjCclY/hrCIMZ5VgOKsCw1nVGM6qxXBWA4azmjGc1YrhrHYMZ3VjOKsPw1n9GM4awnDWKIazxjCcNYHhrGkMZ83ADLivlpURu9+gpTf/9K64MtlL+7nXjvFO1nu9X29d19hbDJ0lJ3/+I3/2qpuzPyyz11w7EFwemuXXy30zPjOiie1ou4YWdBZlx81Q69NSu8N5r+u4RAeydu4Lq9rF9oXqk6Jn/JERXl3oLIpeD8mRkT03jzJFjdW9aPCwe3uA8w6n99XDO6Vqji5NC/sz5t/rl/BXLwriOc6Q4Ybfi+wZ4vF/k1HX7CLXRVyrWTLqmgN1iXAWJ76tUNzhud/5q8Gr4XbGjbbXi0avXtnJ0uV8SUHcEk6ovGAePt3t/XzVHePZsa7GkZz1BiefXBdZ9lGUwmD5hQHGN3nJJJ9LQpjMCcNkLhgmc8UwmTuGybwwTOaDYTI/DJMFYpgsBMNkYRgmC8cwWRSGyWIwTBaHYbIEDJMlYpgsBcNkaRgmy8QwWQ6GyfIxTFaEYbISDJNVYJisGsNktRgma8AwWTOGyVoxTNaOYbJuDJP1YZisH8NkQxgmG8Uw2RiGySYwTDaNYbI5DJMRKEENx5bd84mmc5s64/O02PXB7agzjWINUw01pzo+OylxS+0k+c3ZROUK5V4/fs2+LVXLf23yLCiYZXIh0I6nCD4tk6iXO0byDMAlJzoyd7W7XJsTvRGlIJFz49TV3d17vmmoaCU9/G7+7D00mZRZVvjXIOefITSy09su5U7v0rX4fmTnlXAzrU6HEyXj1H/q/Pf6JfzVi4J4jsT/4RqDgnJx7UM8PgUZdVEucl3EtaIkoy4qUBdL9ApxSnEqORqZXylasoOhN2K356l13TflajfatludkuQ7bioL5lGwiz9SyhckKxwZRBEYMBufkWmxrDDPa7r9QkDJE+aEHdBkKL85YfjNBcNvrhh+c8fwmxeG33ww/OaH4bdADL+FYPgtDMNv4Rh+i8LwWwyG3+Iw/JaA4bdEDL+lYPgtDcNvmRh+y8HwWz6G34ow/FaC4bcKDL9VY/itFsNvDRh+a8bwWyuG39ox/NaN4bc+DL/1Y/htCMNvoxh+G8Pw2wSG36Yx/DaH4TeYo6jMpQZjhV6Uulm/03YbXLE6MmdVxqtBn8mf976P6v8w23LIXilFGfpN5EHC5OXeMrpg4wMnnEITVk6MN88U/nrrt6vfe2fsWK4ayfOS3LWyN98ZGr0bRfF26xuX0slMzgvh4lMcQjM9nfLLhHhI/k7t4+Pte2zFnFRUX9bqi9z76vKeYfmdbWy/4vIilvA/vkPWbzkQz5GaDI/QLLKTiMenIaMu2kWui7hWtGTURQfqUvhqPawbEt0anMQ0vC7EcvVX16957LnUjJ6sSy0Pyx7thROqLphH+VLEpzs7975XijdO6TH9Ihj1Xf56pcBRF3m9a0U/DmgchH5DWc8Jw3ouGNZzxbCeO4b1vDCs54NhPT8M6wViWC8Ew3phGNYLx7BeFIb1YjCsF4dhvQQM6yViWC8Fw3ppGNbLxLBeDob18jGsV4RhvRIM61VgWK8aw3q1GNZrwLBeM4b1WjGs145hvW4M6/VhWK8fw3pDGNYbxbDeGIb1JjCsN41hvTkM60G/oaxHh2E9ejBWmlX77f6DBv69LWaiJre5o+fWsaz4kVQiFNdwe/y3HzUHyXcebSW/1s7W3NPsZtS9p9GuX8nR0HGK4pmdkHd7n0nNvtvQesqaTiaXhvhZvlAfUnf5SNFEmx000cW77esP84Fvd12d9pE8G7PYwHfCcOUXmhOxjxSL96xqOd7r/NxTIm29+fC6a7QRe/6s1b/XL+GvXhTEc6Qnwy4Mi2wq4vEZyKiLcZHrIq4VIxl1MYG6qPkvLXXfZZa1xsLq/tm9Tzjf73s9btZT8XPt1RM1qR82lsMJ1RbOQ3tm+9KV1UutN0zv4G7h21g8xnwsPeL+Nor3p5u3HF5DA62HcqEThgtdMFzoiuFCdwwXemG40AfDhX4YLgzEcGEIhgvDMFwYjuHCKAwXxmC4MA7DhQkYLkzEcGEKhgvTMFyYieHCHAwX5mO4sAjDhSUYLqzAcGE1hgtrMVzYgOHCZgwXtmK4sB3Dhd0YLuzDcGE/hguHMFw4iuHCMQwXTmC4cBrDhXMYLoTWQ7mQDsOFTBguZAZj6UqzojayxrV7fNxmnBhudVLq3mbnmcMH78+w5qZXpYifhS7kqjsvbsFwkvo8ITXlncwb/5cRcoOhPyqWXXEn/Kos8XhE8nuuwo57WuzyGhqfercz0g+m2AheW7KN7/IRicyXzA3PNzpCF1Jx1B8njEaLb2c8bC97snHDFvZJpR/hW50zt4XYR7gZ8P1Zq3+vX8JfvSiI58hMhnNYFtlfxOOzkFEX6yLXRVwrVjLqYgN1cd8sDzVrGde9t1GERsFUqGDwahJ9/qBvTgmfVl3x1Z/hcEL1BfMQzAXFVUPqep/5r3zyrSrCkS0o3Yut4oN6yLfBW8d/iI5CF6IM6YRhSBcMQ7piGNIdw5BeGIb0wTCkH4YhAzEMGYJhyDAMQ4ZjGDIKw5AxGIaMwzBkAoYhEzEMmYJhyDQMQ2ZiGDIHw5D5GIYswjBkCYYhKzAMWY1hyFoMQzZgGLIZw5CtGIZsxzBkN4Yh+zAM2Y9hyCEMQ45iGHIMw5ATGIacxjDkHIYhoQtRhqTDMCQThiHZMAzJDsZK6bekffN3XN2xt+5F5laLqK3yetMWUrqvtbQq6GvyPw1BQ/J0xx4rcfwYyXTvjQj1dOFceIdz6hbC+4G6R2prjt1WkSL5d2SOZXFTQVMzRcfsHgRVxFFXaDRfMX12Yzbpk8jZ2i65QWhIyg3xHm07TRs+bOm8I1krE127P9aXbyTukWiX+qGHbm5Df9bq3+uX8FcvCuI5spNhIo5Fthrx+Bxk1MW5yHUR14qTjLq44OcA37NlMP7gD6uRfvRTW72w5eTn39c+bYpU4b5QL7yrs2sATqixYB7WqG+r1zvThhNi8xO/8AZrMHuw6P6Szd1P3U29ueph2U1oSJQ3nTC86YLhTVcMb7pjeNMLw5s+GN70w/BmIIY3QzC8GYbhzXAMb0ZheDMGw5txGN5MwPBmIoY3UzC8mYbhzUwMb+ZgeDMfw5tFGN4swfBmBYY3qzG8WYvhzQYMbzZjeLMVw5vtGN7sxvBmH4Y3+zG8OYThzVEMb45heHMCw5vTGN6cw/AmNCTKm3QY3mTC8CYbhje5MLzJDcbKHfAqjTu//v2h3RZWsSGvpkKUolz7a4ZY2j4W7FSgPVxO8l3gh1O0gV9O5apFmrxi6dVaXUDbsn377Jcfp9nzNt2i+ZYDvcnVYGu5lO8exVGprDWJ5ynmIqWq8sxsroXtoxI3W5qrZAC9SfM52+uY3OqJFnmvGfW3aV3H3D3fRdeve6xb4TjCTRXR+Wet/r1+CX/1oiCeIzcZfuJZZNcRj89DRl28i1wXca14yaiLD9TF+cZyYCIiS2bFfVPLfsl0tdOBh6TWBjt8GbeYvnttnRMDnHDJgnmoN8idN6C/+GwPV/SN0eYp4QtNB29JxN7lXubfdnbiTvtP6E2UTZ0wbOqCYVNXDJu6Y9jUC8OmPhg29cOwaSCGTUMwbBqGYdNwDJtGYdg0BsOmcRg2TcCwaSKGTVMwbJqGYdNMDJvmYNg0H8OmRRg2LcGwaQWGTasxbFqLYdMGDJs2Y9i0FcOm7Rg27cawaR+GTfsxbDqEYdNRDJuOYdh0AsOm0xg2ncOwKfQmyqZ0GDZlwrApG4ZNuTBsyodhU364DkuWKgp2Db3mD3wzpOfi72VbbW4l3rZO1+YtRdzB+hXS0KacDJ67Q/m2vvHUXb/0Ut/PmRmXMsMnMwSVNy8crVpTD0pAm3J7FV//+WuLTX2HZ00Eq6Q+x9fgbcnX7isZpRadklI8HwltqjL8Yt09bW4PXdOmo8aqdzJLf90ZfbnxtoH2G4LRzrCbXH/W6t/rl/BXLwriOfKTYS2BRTYg8fgCZNQluMh1EddKkIy6hEBdkmnWqcvG1jSz3nfiK/QwS/2d/kTwfLF8a6BRd2VhUfghOOHSBfNQX6t9HZQflWVxOZX9gsQqabdn+dKOOqrjyoY64Ya/SvtIngeIcKwThmNdMBzriuFYdwzHemE41gfDsX4Yjg3EcGwIhmPDMBwbjuHYKAzHxmA4Ng7DsQkYjk3EcGwKhmPTMBybieHYHAzH5mM4tgjDsSUYjq3AcGw1hmNrMRzbgOHYZgzHtmI4th3Dsd0Yju3DcGw/hmOHMBw7iuHYMQzHTmA4dhrDsXMYjoU2RTmWDsOxTBiOZcNwLBeGY/kwHCuE4VhhMFa88tnaSfHbuc/vfGY0Mmi7EZTNo1DBp9Njonj7Ub7NT0boWO6AB4HcBy9aiLAef9f1nur10ibzrjOJoiaHVgmxWRRvboWOpZ6SvfGUym7V2MC1xrb0tZThax+y8Kzg+JzGPBd/0+pnF3SsRNOTsjHFyJflngZvzvb3NzHc3XuU4fO7Q6d0NxiE6qTs/7NW/9ZL+KsXBfEchclwmcgie5F4fBEy6hJd5LqIayVKRl1ioC5ZyxUXzS2e/ljFkvb5BN0Tg54u9mtHO70OUN9WaL9swUviWM0F80g6Pvp6cXVvspv6DxMpBUMNtRcx0t7Xv+6+uMWkzXTv5jMkjkWY1wnDvC4Y5nXFMK87hnm9MMzrg2FePwzzBmKYNwTDvGEY5g3HMG8UhnljMMwbh2HeBAzzJmKYNwXDvGkY5s3EMG8OhnnzMcxbhGHeEgzzVmCYtxrDvLUY5m3AMG8zhnlbMczbjmHebgzz9mGYtx/DvEMY5h3FMO8YhnknMMw7jWHeOQzzQseizEuHYV4mDPOyYZiXC8O8fBjmFcIwrxiGecXBWKpNMRozyxIiE+VYPdoNDyk57DDINvn1WcfVa9/5uucZHdC8NMeKVh+djOJp5ddxCWbTurQmw/PLeNCX5zRF2Ttp7Dn7oXmZo+o2U6+tPmHesGX77cNv3khP+c3welqKXcwoIFglvbwGzSv8PPHu5zPJLh61VlezrsdynqBl7L5/i3eH/vPrcXtWHJH8s1b/Xr+Ev3pR/DlHMgwnsci2JB5fgoy6JBe5LuJaSZJRlxSoS2TnSVaF/d1ThB+rNlpSPXs+rJltcM7Xr/I5rZHWw2ZdkmeMay2YRyk/w+yFkpgiz7LV5w77v/gla5VesuXnrro2L+Ob487jcdC8KB87YfjYBcPHrhg+dsfwsReGj30wfOyH4eNADB+HYPg4DMPH4Rg+jsLwcQyGj+MwfJyA4eNEDB+nYPg4DcPHmRg+zsHwcT6Gj4swfFyC4eMKDB9XY/i4FsPHDRg+bsbwcSuGj9sxfNyN4eM+DB/3Y/h4CMPHoxg+HsPw8QSGj6cxfDyH4WNoXpSP6TB8zIThYzYMH3Nh+JgPw8dCGD4Ww/CxFIaPpcFYgdZjN7R353JdGGG0+ubmdzypcUcmzXeL22YMQw2eF+yGSX4nuvKo2KFJS5uumnVlSV5x9Sf3+ItoPf59x9aGbSLNlKcO+pgmd7zjZIpgisczY1bKo6xuhTTPEmKG7i6dam7mSvEyOEDyPa9jH5c0TLJYBRWEPFBfwReY1yGncNHT9lfQgTSh0hzfe3/W6t/rl/BXLwriOUqT4T2ZRXYo8fgyZNQlu8h1EddKloy65EBdrH1v3926VtzD2ebiW3nWvOrJ9YOjySt3b7+RU13UeJS6Fk6ovWAeMSt+5qW/GD+MOBh/qDTIcsuzSuw8YmYxKpV9STTPfojksw0oSzthWNoFw9KuGJZ2x7C0F4alfTAs7Ydh6UAMS4dgWDoMw9LhGJaOwrB0DIal4zAsnYBh6UQMS6dgWDoNw9KZGJbOwbB0PoalizAsXYJh6QoMS1djWLoWw9INGJZuxrB0K4al2zEs3Y1h6T4MS/djWHoIw9KjGJYew7D0BIalpzEsPYdhaZLnhSIsTYdhaSYMS7NhWJoLw9J8GJYWwrC0GIalpTAsLYdhaXkwluH+6FD57aiVgikjbmpsBqdoZEZypHhbHuwilOvQizUHkPxds550igG/Cd31XU7cjkLWycU2BXXVE/FUKU32xVvt0vKhpdUOhXhoyPz8NPDwsExrcPQ77qwDT5Wo6Omaek+c2lTFTfLbSapvqq0v3Ru4/IiJ5ZgMj8nFIK4c1+OJEmIDa2s915c7SvxZq3+vX8JfvSiI5yhPhg0VFtmsxOMrkFGX4iLXRVwrRTLqUgJ1CX0PoFekjond0ky3uW59xNapmxMpfDZUbSLlSx79upROMqHOgnlUbkQPrjDtjOnri3u5fpXBiRUDrIMpOmWzN3skOgJNw8qgpVHudsJwtwuGu10x3O2O4W4vDHf7YLjbD8PdgRjuDsFwdxiGu8Mx3B2F4e4YDHfHYbg7AcPdiRjuTsFwdxqGuzMx3J2D4e58DHcXYbi7BMPdFRjursZwdy2Guxsw3N2M4e5WDHe3Y7i7G8PdfRju7sdw9xCGu0cx3D2G4e4JDHdPY7h7DsPd0NIod9NhuJsJw91sGO7mwnA3H4a7hTDcLYbhbikMd8thuFsJw93K8N/l6QI1C9gHc1zHBp4fXdZ/wltfkJcm5a7x2mf32a1W7ZSE7lYqdF26J3mTLQsH4+/9RS+7Pj8MDm0RtmuZ4V32ImLE0YLkd+RjVeSot8jt5yoOrvJJf/uhtFcg6I7y4eA89dvtNlpv9aC7OVIqGDWuHKgtcPpqJZy+876I72GWbSPyMj8GP5TW0wbl/Vmrf69fwl+9KIjnqEyGI1UW2bfE46uQUZfqItdFXCtVMupSg/dqBtfKtJlDyn2Dm55ouIxYxPCu+uZyQGfpLTkJ95HrLbvhhLoL5hGzErE22C7ykneluPqbeAM/gV+XLgRPKhbK7Fad4BjyXwXdjTK6E4bRXTCM7ophdHcMo3thGN0Hw+h+GEYPxDB6CIbRwzCMHo5h9CgMo8dgGD0Ow+gJGEZPxDB6CobR0zCMnolh9BwMo+djGL0Iw+glGEavwDB6NYbRazGM3oBh9GYMo7diGL0dw+jdGEbvwzB6P4bRhzCMPoph9DEMo09gGH0aw+hzGEaH7kYZnQ7D6EwYRmfDMDoXhtH5MIwuhGF0MQyjS2EYXQ7D6EoYRlfDMLo6/L6Y8WeDddpOVuEjpwPDN+5r81kTSfXcY+UBgSO3a82fRf+CRqfSYkrV9nf5arx519esbV6DGdrvX2wJVnxrzqWwdaO37lFodP7h6+cKnC4ZFQnw/97C6P70cuWm4LYrL7lVs1b9ZhpR/gWNrqTzSsymM3RWwi/rtJD9B9MPmiENpwY3aUk+awqk3nXl4J+1+vf6JfzVi4J4jupkmFNjkS1MPL4GGXUtWeS6iGu1hIy6loK6JHz1pL3lKjyHJbI0XnO0tndcS3Q5ubrtpP2lc56qA9ShcMJlC+ZRkarPlTPVvX+ZoSc73nkDTdT+pPrdTYy+V3imXXs1u+6T/t34/7fnnTA874LheVcMz7tjeN4Lw/M+GJ73w/B8IIbnQzA8H4bh+XAMz0dheD4Gw/NxGJ5PwPB8IobnUzA8n4bh+UwMz+dgeD4fw/NFGJ4vwfB8BYbnqzE8X4vh+QYMzzdjeL4Vw/PtGJ7vxvB8H4bn+zE8P4Th+VEMz49heH4Cw/PTGJ6fw/A8NDrK83QYnmfC8Dwbhue5MDzPh+F5IQzPi2F4XgrD83IYnlfC8LwahueXYnheE4ylTd3Q5p+kwdWQvnXIwW7yQe2R1Fj/wqVH798PiKSvdfSCnmeQeRb62aNwhUG10StCShLnmKDnSJdDgN5j7XeDyec2mkLPM3xVuHjvo73piNHhMe4DkiFvtPL3tSbYtmgofL4S7BnvBT0ve2ZntKKmRFF1oOEX9x1NE+st3TrMzF6mH7jq/s7Kl83jz1r9e/0S/upFQTxHTTJ8qrXIbiYeX4uMurQXuS7iWmmTUZcO9PyuWdu1rA+dblG16L6ffh+W1vuRdUb+Csdxhjze9A71ETih3oJ5FIyuJ37JU55zsB/a//PL2mz2QcFiqexbcrlbrhUGss2Ik/ydO8L+Thj2d8GwvyuG/d0x7O+FYX8fDPv7Ydg/EMP+IRj2D8OwfziG/aMw7B+DYf84DPsnYNg/EcP+KRj2T8OwfyaG/XMw7J+PYf8iDPuXYNi/AsP+1Rj2r8WwfwOG/Zsx7N+KYf92DPt3Y9i/D8P+/Rj2H8Kw/yiG/ccw7D+BYf9pDPvPYdgfeh5lfzoM+zNh2J8Nw/5cGPbnw7C/EIb9xTDsL4VhfzkM+yth2F8Nw/5LMeyvg2F/XTBW7KJZ3bYPTqF85wcLv7I9jJFeXhNymDuyiU97E1sS6/av0P60r9Yy2627Rp92yWTToJL5+eunHrftyl79pv1MX3n/7shL0P6sy+q6nvAaNWqwCz4spGB6rEYrqm0aUS9s07xH9136h1Jof/b46y/3737fdKL03DPlfsN9Ze5rvmpxnHujZr9uh2Dw3PSftfr3+iX81YuCeI66ZFh22SIbm3j8ZWTUpbfIdRHXSo+MuvRBXaJebM+HSzqCIzu+PIuprGErLos722eQ7MF5X0Vked+wOJxQf8E8jEeM9ni+aTv7RNOdYftb5QPxj+eoLNtd41lu3fx967LqHLQ/ap/ghLFPcMHYJ7hi7BPcMfYJXhj7BB+MfYIfxj4hEGOfEIKxTwjD2CeEY+wTojD2CTEY+4Q4jH1CAsY+IRFjn5CCsU9Iw9gnZGLsE3Iw9gn5GPuEIox9QgnGPqECY59QjbFPqMXYJzRg7BOaMfYJrRj7hHaMfUI3xj6hD2Of0I+xTxjC2CeMYuwTxjD2CRMY+4RpjH3CHMY+AdoftU+gw9gnMGHsE9gw9glcGPsEPox9ghDGPkEMY58ghbFPkMPYJyhh7BPUMPYJSzH2CToY+wR9jH3CcjCWzSY/8t2ddqN7Cq9uJHvWuX7tYp1rPXX9Q4HA8yUMl47OwH0CSzWrzI3zyj53M2+/4tj6q2XsMO36y+ejsrdXBbzpOnXWCO4TpN6mnHdYb6TGWcl/wfiG8azxeielX3nrJteuUtqlsnEfyW+Ii+bn3xGv51z15uCL9BuP0jPVlFdEbhJeImWxYk9xrNGdK3/W6t/rl/BXLwriOS4nw70Gi+xx4vENyKhrxSLXRVyrFWTUZQjqUttjWndfoGRdgqje+cOOt2xMLm8si9LNKf3IGhB+YO6wGJxw+YJ5hO/R33RRXj4QfHHuwKvZOzzpp2h4P1Pemdk4Xqg6d2zNPbhPQO0pnDD2FC4YewpXjD2FO8aewgtjT+GDsafww9hTBGLsKUIw9hRhGHuKcIw9RRTGniIGY08Rh7GnSMDYUyRi7ClSMPYUaRh7ikyMPUUOxp4iH2NPUYSxpyjB2FNUYOwpqjH2FLUYe4oGjD1FM8aeohVjT9GOsafoxthT9GHsKfox9hRDGHuKUYw9xRjGnmICY08xjbGnmMPYU8B9AmpPQYexp2DC2FOwYewpuDD2FHwYewohjD2FGMaeQgpjTyGHsadQwthTqGHsKZZi7Cl0MPYU+hh7CkOMPYURvH5L0iTXrM7U3Fp+g8NotlVfn+moRmsxB92cqOVN6bffT8A9hdSvys+J721Wi16xi9oRc/5RBgOjgO19j/ExF1Zt+Ra1IbinEKjZ1eCdfKTca/3EY4mRJVNzKf5sASetV0Rbvrs0Has3Q/K8SielpzaafT+7No2Oa5qYTHj9nN2v4ERVouIdzjqyXl/tz1r9e/0S/upFQTxHIzKMbLzIdice35iMukwWuS7iWpmQUZcpqEv6yO8ODb7h5ujoRmrXlWnqegI7WG88j1rVXGo4eZIjLwpOaLBgHlWFs48DZZzZFGs4DtPsMlj5I12M+an0obcX76f48NK388M9BWr/4YSx/3DB2H+4Yuw/3DH2H14Y+w8fjP2HH8b+IxBj/xGCsf8Iw9h/hGPsP6Iw9h8xGPuPOIz9RwLG/iMRY/+RgrH/SMPYf2Ri7D9yMPYf+Rj7jyKM/UcJxv6jAmP/UY2x/6jF2H80YOw/mjH2H60Y+492jP1HN8b+ow9j/9GPsf8Ywth/jGLsP8Yw9h8TGPuPaYz9xxzG/gPuKVD7DzqM/QcTxv6DDWP/wYWx/+DD2H8IYew/xDD2H1IY+w85jP2HEsb+Qw1j/7EUY/+hg7H/0MfYfxhi7D9MMfYfK8FYpWhZ061nT66gd9NlfaiVyTT4VsPNLtlXfunBod7cqimS35OSjX38zafZkeP7mwe/pCo1hYVjHqhVvvJRdO5anSt9/rIr3H+I8nbk3ltT43+P19SivcPyhkbysg6XYDWZyb30rWGXd+mTfO/BXK5F8va6XU2dH4s85MWra+2ubR0UpLRyC162leXXhz9//U3x7/VL+KsXBfEcV5Lh6VWL7Hzi8VeRUZcZZl3/vhY6n9OXUC5j0OPNX+Onmtl5fF/jznuWDbu/vbvVMFriV1IYBJ0vIVFU9zlRT+uhHFv+6xe/Nrx7fW+9x8MjS4PY1zIZR21/CZ0vs+JWjl7YWLb2KSrWJedqe35KK7a6xUc8Phx/RvZ9X6wMdD7n2t0+ph+v/Rr6KTkRoGfQ/6rky2NfhlMauzQN+ig+mhtD59PyTlasczjmmH3z3q+m7iS/n9NZbR725g4J9wMpGn+eeA2dr3jqKYcZE9/JfNfP2WEHzLc9f+nsZfTkMsOVxIDTCqUh3CTPpT+1+Zhl2KpY3hG2zbtTm3qybrRVZ539wZO3SVvjwvuqZOh8vrIZvnVtd4c+p6Q3TVLc3RegxZC+8VXWtnQavS3ph5MaoPOlpF7PfH93bn9Vdn7u9K87awtTxjvqtF7X7N7yzEw9KlsfOl/W5NHbXpdofTpaLS/7i8uvXNM6fbCt+Ht/WwJVGevtX7ug87lp9j1aweivWHHN4Ii+qd6U6bgm/embxy2cyl9kPVTOPA+dL9eoV2IvpsC64+jOQgEddsvRI/kT4W/XDmh+eKnNT3PlLHS+SKDvLU1hu338nLIhayOXNwrSxlkYUk4klgq9X/5DxM4QOp/CZ2R1056kmN9ip+wPbzvlNmXCYM70o82d4xmDo8Dgby6S7wsv28VEXzDbReV+6wiPVeknzaToY5kigSxVfVcGkpuzBaHzJeX7HKa38ypZHKw0/eUvN7KcIHE3Il9I9mLsNS5nKRGS59KzT6Z99TQOChbmdJoZz81Zfuvq9PoOM1l3leBI0S0rDlSR/NvBs69MJa1lbXeWszo62xXu3/ekK2R3rg1fnUt3afyHge/Q+dyCh+nZtQ++lxl+9LWkIzba6JCdQ5osj632zKbpUwVLX0Hn0+29LKgXmfS1J2EDdx3VsosXA273xD9mezgiGqizryy8mcT5A2e6R9sbQ20zzhHMrA1s38nfpW8dpNE+Ul6zRrtfYC90vnzpc3NKxQgH191Rc1soHh3jzXM75rf20ky5UTNT4f2vhtD5BJXikaDPn+9PaR8f3SwcP1F0dU2Qqb2+nfOuqFxNqsNfoPPlk89RUG1Xju07eFrhUcgdnhcfI53fT/YI8tmIxwg3UA+TPEvzGY1q1cmCvCSnspf83m2CqXSpDV4yk8lfTPJiKzOXp0Dn828fDDnr7yc5kS3qEnx629FHBKbRsALKIXVZr/eMx3z6oPPZxD0SVR/Lsj16qiflSpXkszp/enNHusgJrzfm+7kKH32Hzlf+dru10pSBPf74gydR0bWB155nt8hbBx2dmtKNvxMbUQWdzxFxw//2fn5qlxNffkv/SHtpu83/Vc7SrWHBIbdfDA+tbIHO5wprvFYZqZ/wlHLMMGz4kDtLzmzTtWGGifMntzSGqzKxQ+erhr66GxVOF8qleH8ko/Siml3qSiPL5+OVA1u80x7OqH2EzuefVjWbEYqYFTaPGvW6/4rD8vimUA25YNZz9MH0Ovpf7kPnKy7Nf7ulf3bLL62tH26u1XH33PfNRPvbsa0m4Qo/h4U606HzRQKKO+qUnt86omPSL54/W/75GL8aR2kVC5e9P4dV6loH6Hz2LWtqNmhesrPwFGrlEpkaaj3D/qVRvfd+/fL9L9qjRMxInP/cnvbu6xYW/9bnN7uml7y6t/LCJvnwO1fzuhImQqs9NkHnc7m8T/n/9Xbn0VC2YQPAjWXslBSiN2vGMowUibKTEJOdsY51spU9kkKWKEtCQpQlW5Yia/ZsGYSyRHaJhCxZ6jvj6z3n1jnf0cz76f5r/rify3Xd9/U88zPLMwsh3M1i7Pe7r1S4tVDaDZL7RF4usGT9pBnpSe8KOp+8WO5A+BbGoZM/VZgik8/B1hwV4LlwegHzubxI4nH0ju8XMG/eMQtzMRKQpHXzVyLm1dPV+xnqkT0pXvk2FzaeKhUMOp/X0H/dmOW5lqnVJ6undDkJq855CZ3vCp7dM03z7WkacgSdT/ku5R/ermURyhJpVyP4/JxVn2omPeJuwcPJHvsExflvoPOFrC2Jcx42BIs4iqKuRQ+cUA7+UvsaPiwdcUPWxf5zXRXofN6fejUtAb56HFTeChNCuojF+IZvyNePeg6mXCqqFB0VB51P+5PFP5rC0O0CrVNeg+r0kTvDt2tN+vufh95a7+2n2jADnU+aT0ObsoaciEPna1WqmQWx0FMPtvcloiZXrspRSXaugs7njpDLHNx/lLc+LzFfoTq/aIFOr8OEUkR//q3bMNEMuy3ofBpftRkxFLt5FBVNcledWbqmRXQFsUZnizR1CaI/GKOx4/vCqt8yBqf0fQSDaqPHyn2S+L3XTfm21IeyjKVtVI6cqASdz1CdauLcAZ1tf5ybYWydEKaleh8WsfSz+lARM6bXrfQk6HwB9qi1SwZeGT80fDj7dI9KLgZy+qfrBtOXGHwMonyULgw6n/itkwwftx5pW8AwcaxzmIm+Yh1mCvpayIbhdojKTMEz0PlkM8S9RuzJDhnoQPt7xfJhnpl5799O+gZd3Zcpc8X1sC7ofCFPV7RMYXoXZ2PKJsWp3OUfEGmJAmuaqcdTrgLC4lXXQefzEaManTpk6zcDTB6yCXbCAu02uM+QJvS6pSc2hRS284POhxK97iq+h1acWPgys2HyclbAETsB66q++OYW1cb506lXQOezCy7r9fLUmvl9poBZZNjowTyvFNyYjo/lSFJ1cx9VR4DO57Nb9J0TeeJXWmfvLu810CLYtNUpizoz1MsnUzFE/e4yPs5XBuYKKr0/c+ILG+uDcUq/tbSDYkgu+aEIOz5BIaeYZg7LBEbQ+USxX7X0b7PGLTA0BX+bnrMewurBJ5Ta34kTaWdovKNpBJ1/AH4DuYLWjw5kgnEbf4xqIAmv/4hd/lGjQhZ4ha3EQxR0PrtNjzhE+BFqnev+ZYmZD3XG/xyeXwonbpZ1xxa/3e+5/ZkXyL9zif5oQHA1KhPg6XN77Hxc/HME5KXy/+R8KNrqWWeo7Hz0zU3qI8dQz9+2K1OFlb/0XO32Q6LJlStB57Nc0taoys+IwpbfrA2Z8Cp5o+NXO3bqcUiH1vztM/um6EDnI5Su1UTTY35ENCXKkOfybWoYslRDO0lIT9U4rOmKV5qCzme547NpnafoIaODJZeca1ZM+95Q8DCP4l1Im965nyPxhaDzmY/Y5qcEa6roly48LB+I5Q88i5w7ZXLO/8lpOX8YiTg16Hx6n56fT6yZENm648rrE21M6FYleCZVoLkalzcf7aceYtD5ZDbi2s6dIcXROR7Z0iU6V0R6EC4xR+QblAKDHpZkJreCzidbk69FcH8+ku1b3mRD+YgjK73lm+jqHE8oBfpOTEARHHQ+sX1g6XD5+N1pSbfTJi5ipd/ove//81D7+wVxZyKX7i5H0PkcmyKSKWxm09MaK7Sl0EdfRZgTqM+JouQ4vlPmrYnViO5wvnPS8b7Q8TfMz4mY/7mcHWtQL9Y0LZ0ef3rACV5c/rQDdP6BuaSkS4rwxetFJ6U2BXvPVt24zsEv0ZhZnqBwuEZC3xx0Pqtse9JbtFqlXD1vuxrK30NWZTR9oMuUG8IeMXBtfOo76Hx2F+x3uIjscz/3kxLYxdhQNS+FK2zN4mVEbYG8vAqXx0Dnw7i5JV5wa1MhuhNsR5JEyi4GVEpi/6EXll29piXyPXkddD75uKBgumhXfXL2mkSksgP7PZExdb/jxSml7m5LDTbfFXZ8RqjtmdOx1WNXiY19nuuO5RUiU9LZs1Z0Q1Exlmo+BoxtoPOhQ8iD7KMeJcPkdVroGzVnn6utRqQisusiKWLNXtXT7XA+ZdcM2bx2/0CVh5OMeov1sTZqHol46uqXr6ZdYxdGG0pA5zMEXnGrEp4sLRNqvBthbil9tKEvtWHcV8dW3npCFcGnBDqf+WSh21BeVwc56dO6No7sqwqPlSxiw7VqIgZ5PtmlkRfuuHdn5ZOo+61tSFuM9wabxNKitjhlYIq12XzvxHu4BvQOK+h8Tt+pp4pzeZOR95hni3gT9k+uKywvN2Rv3MeoTsS33noNOh/CsPK+W4CKluE0+S1UirjDElNqisYmJJLT6VRm7pbFKdD5ZP71XVE9GlIDzsEkk6J3G58NMIcbX0iGQqJvigU027vtcP6APMdrjmox67kQ3qa4iKzQXFaiam1tb1SKWp/6uE0x6HxhNTs+T+tKxUxeOpZ7LMfa67TYkhjqa5tULsuorpPKRIDOZ6QvehCy6OQQhHV/g5ruV84yDiU+y42FOGItsV5ScX6g8/kiCqVuBAt7UC69jHw01q9ux2QjDDfcJ7vlXWkTJUp7CHS+kPl4BfEhxH4ll6+rl83zdAY7nqM+Xnswtsj64jELPWP1jnt3LnVpMGEbyahoXlmOLHj6cupVSUmmk9dOb9YsYl6JkILOJ7/6g8frm1CN2vF5cvPR01LVuRbo9DBUMcuhSj0GWmbbHb8/lS96xFfg4LMLNeZNjgFlmEIyM4+pLDexE7R1zD5tmYWg80n9oOqqZ/Nz0z49nuowQJTUSVzvLVU/d4Cxks2OiqnZa8d9gaqsl8Jv5cffjrbStij45lZalTgGHdHszrG8m30mH7sCOp99ZNq93hVDU/kA+e6SEM8al3ldyLj0taPIDKqsWiVaL9D5bKkkJyFlj1cRNvUI+vzl/SxzemIbTQsrzdxlX4cN6ZJA5x9J7JdP1Yn+2cXjcCLq6EvHd3Tu1BkO5p9a64o/0B/m0ASdD1uVqdh/85Oz4yuSVmmt7MwnUh+LmT1P69w6FeqmvJ55EHS+UFAIj29Xa1urPJnteELzIL+uqIFfWFxs+1mZ9JXUq5mg82HwQJ8f4Y9f7LvABuPa8DF64M0TpdFvEJNfh8wSCEr8CTqf6aIQXZLlakwqccq+Uf/1XGe9vIbmuQeHXaPoee8tBMaAzmc7fIeTi6qiU8rok5nIqxSbANr93lIYQ6r9VccyljcO39tx784eGm4XxksV7rymbfqJJOGz4YVBMM9kWHHPMmnlIcWWHb8/FS/7xF4guo8B43wIQZmRw7uW2S10EnJbcjZs8MWHLRvQ+dCp+IphgfOu2jDtJeI4ktE1RU3riyTHvc9S8MS6Hvh0CXQ+R/9RZ9Ycj4ryLESfZe/KypkqVva+3riw8DfeT5ivHBwGnS9sX9Z4r+lWPpzqok+Oq0axfpcdHccZ1+NfJq/bFyc71+54PX/+IVfADVibcO/mrcRF9asvHLdOJH3Q/ZYcrsF1Y/i4Aej8g9ZFMnAP1TAKRvNgOUMFbk1sMxHW8qzLzcL3mlehpnM77t35su34JZMRs2WRuFqmjRPT8ZXj9u/h2YMwdS9kj9KaPuh8ytVW2+6x4DUtaywWdj7E+LaFZnsv7/S+Gx7y7SSiVDo77nOexTt1kDr3AxRx+v3E+Cs5lZKZACutocU7NhcN3k40IUHnH6REf815WlEle4zjfGkjb/rqnAvbuh3S9qWxlipTlfQ50Plk9ykk7WMFahCcKUtnrLiee0gLdjzxG0l6xIBk+XpKjwx0Pp0um/Tt7lVH9+6kWEY4JxSy0fDoTIShMmzmaMxWMHch6HxGBMesLUZalNY0yUrpFBQ1+cZrNMxIXOu4hcIXq5SCDHycfx6YCzcN8uNDu3e1KMqlplyrUP68rmo9EZa4lUWTFgbNpRcDnc9ZP8OjHLUxO9GBNSalynJ0kzOTqH1X/aF5w+lE3M28F6Dzec/LKUJmqEVUltCD6MTBE7PqZqyHVM59HChIHNUf+1ADOl/YIUYCCa3rSzn/2ZoIbmTVTPt0YdJKYl8vzf4zhltlzdt98Gvuv8fsMiC4Gs8T4GnVPXY+Lr4qAXmp/ce8dns/CPfehxIBeTVR/re8Ds3JjkiWVjdiRljkND5UVEQzDiYPDM3o9DYqyg+qkHzE/a+mQkBezf8xL4GI8kf0LWQhK0xTg6+mhWhXodmWNJ+5vb0OR5dcEHNxwPWWGgF5teCZ17+DFM+/o/7n/QLBYw8heKwrBKyVbUPXYhpr2MyJ8fvCVISpanXJNg0aMY/yllcZoVMdptg+4Ndc9j+Mj6tRnYA9uLDH5zgu/gUC8tIg/ju9oQk+Z/ai5WTcups3m6CXEt9LHZfjv8lvLp5TjVG6dTOT+64L2Bv08b10Yqf8X4UrV3+Ey5L7jt/IoCnivaYY5810eYMjlRfsDe4Hs47hXjCDILkGdBKFOEuRrxILx2R+bkzskeShwgBFsDfoOZh8EfwerGWT7ztni1yKBeOfnbBgz4HwNUhbOxbK/u+i/lbjLgOCq1GTgD1A7nFv4OIjCcjr4l/qDS3QBhYJ6wrJg5ldFUYZMXWMawyx1fkv71xjqGFgdq7l1PXfcd1os1DaOLC+5hNhzrHgN6Yc5IzJyZ5EvywKZ70tWptdCfbGvqEqCn3sKLOWk6TFuKhRTBm5gFhtbfDGZt/9T3IdDZxgbxy6fJHL1cwu6tkG7btVVoaqei7M3CQfmVLFvO9RJIprexq+e4CrUYuAPdDe497AxdcmIC+dPbYB7hqrQUBerXtsA9z5fZGAvNr22Aa43tIhIK83f8kGunjYAI89hOCxrhCwVvrHs0b3gnkeCj3HcmuyrvdVCTWPC6Ka2rpZutKjWt47bx/way77H8bH1ahLwB7o7fE5jouvR0Be+n/p+m+Ahw1a8bBBGx42AHuDRYqO9GMln79e6zH7g1AKureOg9Moy7DqwOkG78MvVMu2F/W3GncZEFyNBgTsgeEe9wYuviEBeRn9pd5A4WGDVjxs0IaHDcDe2Mc/fGdV+WSqbyQM4dBa15zsdCXyjYyVZzvjDH9/me3a9qL+VuMuA4KrEUXAHhjvcW/g4hsTkJfJHtsAd43VJyCv9j22Ae78NiIgL+we2wDXWyYE5NXxl2xgiocN8NhDCB7rCgFrpf/4zFN/PM5gNE3d6XCfYoEIJlV14wNXnkx6R6tz3UzB9gG/5rL/YXxcjaYE7IHZHp/juPhmBORl/peu/xZ42KAdDxtg8bAB2BscTjZM5a+HBii0MJzsAdIX4GkL/U8/D21Np824KHiFc24v6m817jIguBotCNgD9B73Bi4+moC8LP9Sb1jhYYN2PGyAxcMGYG8cSUM1E33tOnr+rJ18ZGQoqxRXYY6H1KWza3eE5GDHkebbi/pbjbsMCK5GKwL2wHqPewMX35qAvGzwzIvkt/i72QB3jQWvTbs9Z+POO7Bfd3suxe2FDQF1kxD9ed3EwGMIsAbEvx6T/h9z9X8lpYcsh6fZFr0AY0b+mqgRAHWiDTrQQvTb+B8dLbfepCkEAA==","debug_symbols":"tZrNbtw4FoXfpdZe6F7ew59+lcGg4SROw4DhBE7SwCDodx9R5FdOFiWoLXhjXvOQx0cSPxYt++fl08OHH3/9+fj8+cu3yx//+Xn58PL49PT4159PXz7ef3/88rz2/vzn7sK3f35/eXhYuy6/6Ousr/cvD8/fL388/3h6urv8ff/0Yxv07ev989Z+v39Z1eXu8vD8aW1Xw8+PTw+9+ufudfZye2ptNie3VK7TZb/Nt9vzbVGZBraUeHXIvzn4bYdobRoo5df5+m1+2kmwBidBy79cQznq4Iv7dPAlxS0H7VyDSpoOa1nf5HC9DZGX/BaHbPnq4PVN96Fc74N5vMXB9OpQbl6F7SzIlIPLSPn249y3SEcsdq+jsabcl3YzRDq9JPYtDq2JXYvzi8JTu96KZm9xSMYe4yl08zLq+UVR33VRhK7XEfnm4/Cd3bJYiWlRrL5u11aPW/h1syqeblrsXkdlZbriTXdC103fVf0tDrnyNLxEepPDla+3OlQTDvWXh/FvHJZ0ziHZ66q0uM3ncnqj2bc4tNHsWpzeaNL66c2t8DctqpSMk1BKtz/Hk05vNPsWZzealKTrdew41POLop5fFPVdF0Wq7LkplpufHeGnH+m+xaFHuoNHEyuz1XzrmL0z3yzxPM3Ubjn0K7150i9EqLXcOqdH2bsLbPqxxK2DetTTJ/U9i6NH9fP7pc7vlzq/X+7fi0PH9V2LY+d1nd8xdX7H3L+QQwd2nd8ydX7LVH3fdXHsxL5rcezIntPpdbFvcX5dHDuz53z6zL5rcezMvn8hhw7tuxbHTu27FseO7fsWh87tuxbHDu77FodO7nsWB4/u5fxro3L+vVHRu245B8/uuxbHDu/1/KujurzrlnPw9F7Pvzuq598d1fS+6+LY8b2W8w+1vOfx3ex61DJf6m/H7/+u391/fHz57c3+ZVmZu7vYGuzu4tvXtPXEVmv7mreestV1+9rWz5F11jIaG42PZsy3YWAancPChofV0dm2Tl/GDx8u7qMzjc4YncPF82jKaIaLD5c0XNJwScMlDZc0XJJGZx6dwyXV0dm2zlhdbP0UDZutzzbNNma7WvW9PVavvviizP46+9vo1/STjX757J9+itmv2Z/7WWhty2zrbNto8zJbm633g8/apv5ZubYx+zXbPPUy9emXp19Zhl5s6MVnf5ptTF1Tn/nKzFfq1NvQ68xXZ74689WZr858dearM1+d+erMV2e+NvO1ma/NfG3mazNfm/nazNdmvjbztZnPlhnQFqOYEW1JjAkkUWTGFMZUpJnUbEY1m1nNHClRBGPEmIxUKCpjyOxkdjI7mZ3MTmYns5PZyexkdjInMicyJzInMicyJzInMicyJzInMgeZg8xB5iBzkDnIHGQOMgeZg8wis8gsMovMIrPIDFgGWSYyi8zAZdBl4GXwZQBmEGYgZjBmQGZQZmBmcGaAZpBmoGawZsBm0GbgZvBmAGcQZyBnMGdAZ1BnYGdwZ4BnkGegZ7BnwGfQZ+Bn8GcAaBBoIGgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6DDoMOgw6J3BZL1Q/9WjF7kfO3tRkCpSm1JncJM6g5vUGRxSQgokIWUknDuDo2ijSMtCMZ3TMp3TkpACSUgZqSBVJJw7g5vUGdykzuCQcLagEAXOhrPhbDg7zo6z49wZHFIg4dwZHFJB6s6tF20WncFRGIVTpP4auRerc3TDzuCQMlJBwrkzuEmdwU0KnDuDQ0pI3Vm9WJ37e87UGVSP2hkcRe2H+F60OaYzuEmdwU3qDA4pIQUSzsK5MzgknDuDW9EZHIXNWZ3BbVZncEiBJKSMVJAqUnfu194ZHIVROMXqnPtt6Qzm7tMZHFJGKkgVqU2pM7hJncH+/j91BkeRKIJCFN25/y7QGSybT0Vqs+gMbmM6g9uYhnPDuTM4xogxGalQVMa0MSY6g12KxSh8jInO4BgTSKLIjCmMqUgzc9jMHDYzhzlSogjGiDEZqVBUxpDZyexkdjI7mZ3MTmYns5PZyexkTmROZE5kTmROZE5kTmROZE5kTmQOMgeZg8xB5iBzkDnIHGQOMgeZRWaRWWQWmUVmkVlkFplFZpE5kzmTOZM5kzmTOZM5kzmTOZM5k7mQuZC5kLmQuZC5kLmQuZC5kLmQuZIZBqOSuZIZBgMGAwYDBgMGAwYDBgMGAwYDBgMGAwYDBgMGAwYDBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGBQMCgYFAwKBgWDgkHBoGAww2CGwQyDGQYzDGYYzDCYYTDDYIbBDIMZBnNnsORedOdtzOpctjFCykgFqSK1KXUGN6kzuEmO88bgVgSFmJWZVZAqUptSZ3CTNga7tL3M3CScE86JzJ3BURRmVWa1KXUGN6kzuElB5uBuBHejM1ijF5miUFSK/tK0v1XsDPY/uOXO4CZ1BoeUkAJJSBlpdW79b1t/37883n94evh22f7n/POP54+//Av69/99ReGf1L++fPn48OnHy0N/qb1p62vu/wM=","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use dep::poseidon::poseidon::bn254;\n\n/// GhostSats ZK Withdrawal Proof Circuit\n///\n/// Proves knowledge of (secret, blinder) that hash to a public commitment\n/// and that the nullifier is correctly derived from the secret.\n///\n/// Private inputs: secret, blinder (never appear in calldata)\n/// Public inputs: zk_commitment, nullifier_hash, denomination\n///\n/// This eliminates the need to send secret/blinder as calldata during withdrawal,\n/// preventing observers from correlating deposits with withdrawals.\n\nfn main(\n    // Private witness inputs (hidden from calldata)\n    secret: Field,\n    blinder: Field,\n\n    // Public inputs (verified on-chain via Garaga)\n    zk_commitment: pub Field,\n    nullifier_hash: pub Field,\n    denomination: pub Field,\n) {\n    // 1. Verify commitment preimage\n    // commitment = Poseidon_BN254(secret, blinder, denomination)\n    let computed_commitment = bn254::hash_3([secret, blinder, denomination]);\n    assert(computed_commitment == zk_commitment, \"Invalid commitment preimage\");\n\n    // 2. Verify nullifier derivation\n    // nullifier = Poseidon_BN254(secret, 1)\n    let computed_nullifier = bn254::hash_2([secret, 1]);\n    assert(computed_nullifier == nullifier_hash, \"Invalid nullifier derivation\");\n}\n\n#[test]\nfn test_valid_proof() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n\n    let expected_commitment = bn254::hash_3([secret, blinder, denomination]);\n    let expected_nullifier = bn254::hash_2([secret, 1]);\n\n    main(secret, blinder, expected_commitment, expected_nullifier, denomination);\n}\n\n#[test(should_fail_with = \"Invalid commitment preimage\")]\nfn test_invalid_commitment() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n\n    let expected_nullifier = bn254::hash_2([secret, 1]);\n\n    main(secret, blinder, 999999, expected_nullifier, denomination);\n}\n\n#[test(should_fail_with = \"Invalid nullifier derivation\")]\nfn test_invalid_nullifier() {\n    let secret = 12345;\n    let blinder = 67890;\n    let denomination = 1;\n\n    let expected_commitment = bn254::hash_3([secret, blinder, denomination]);\n\n    main(secret, blinder, expected_commitment, 888888, denomination);\n}\n","path":"/Users/macbookair/projects/ghost-sats/circuits/ghostsats/src/main.nr"},"55":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"56":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"57":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/macbookair/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}